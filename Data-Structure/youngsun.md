### Stack과 Queue의 실사용 예를 들어 간단히 설명해주세요.

---

- 스택
    - 스택이란 쌓아올린단 의미로 새로운 값이 들어와도 top 위에 쌓이게 되는것 (push)
    - 데이터를 삭제하고 싶다면 가장 마지막에 들어온 자료가 삭제됨 (pop)
    - 예를 들어 우리가 웹페이지에서 뒤로가기를 누르면 가장 마지막에 봤던 페이지가 나옴
    - 삽입, 삭제:  O(1)
        - 맨위에 데이터를 삽입하거나 맨 위 데이터를 삭제하면 됨
    - 탐색: O(n)
        - 특정 데이터가 나올때까지 수행해야 함

- 큐
    - 큐란 줄을 서서 기다리는 것을 의미한다.
    - 새로 자료가 들어온다면 가장 마지막(rear)에 들어오고 (Enqueue)
    자료가 삭제된다면 가장 앞(front)에 있는 자료가 삭제된다. (dequeue)
    - 예를 들어 편의점 알바할 때 유통기한이 얼마 남지 않은 제품을 가장 앞에두어
    맨 앞의 제품이 빠져 나가게 만든 것을 큐라고 할 수 있다.
    - 삽입, 삭제:  O(1)
    - 탐색: O(n)

- 덱
    - 양 끝이 rear이면서 front인 형태
    - 양쪽 끝에서 데이터의 삭제와 삽입 가능
    - 삽입, 삭제:  O(1)
    - 탐색: O(1)
        - index로 요소들 탐색 가능

[스택 (Stack), 큐 (Queue), 덱 (Deque)](https://dejavuhyo.github.io/posts/stack-queue-deque/)

### Array와 ArrayList의 차이점에 대해 설명해주세요.

---

<자바>

```java
public static void main(String []args) {
		int [] arr  = new int[5];
		arr[0] = 1;
		arr[1] = 5;
		arr[2] = 3;
		arr[3] = 1;
		arr[4] = 6;
		
		for(int i=0; i<arr.length; i++) {
			System.out.println("Array의 "+ i + "번째 데이터 : "+arr[i]);
		}
}
```

- array
    - 고정 길이의 배열, 초기화 할 때 배열의 크기를 지정
    - 배열을 초기화할 때 메모리가 할당되어 속도가 빠르다.
    - 데이터의 순서가 있고 중복도 가능

```java
List <Integer> arrList = new ArrayList<>();
		arrList.add(5);  //add 데이터 입력
		arrList.add(5);
		arrList.add(7);
		arrList.add(20);
		
		
		arrList.set(0, 100); //set 데이터 수정
		arrList.set(1, 200);
		arrList.remove(3); //remove 데이터 삭제
	
		for(int i=0; i<arrList.size(); i++) {
			System.out.println("ArrayList의 "+ i +"번째 데이터" + arrList.get(i));
		}
```

- arrayList
    - 가변 길이를 갖는 배열 → 배열의 크기를 런타임시에 정한다.
    - array에 비해 속도가 느리다.
    - 데이터의 순서가 있고 중복도 가능
    - 배열의 1.5배씩 커진다.

### Array와 LinkedList의 장/단점에 대해 설명해주세요.

---

- Array
    - 배열의 요소의 주소인 인덱스란 개념 존재
    - 특정 크기만큼 연속된 메모리 공간에 데이터를 저장
    - 처음 주소만 알면 다른 위치도 쉽게 알 수 있음
    - 데이터 조회 → O(1)
    - 스택 영역에 메모리 할당
    - 장점
        - 원하는 값에 빠르게 탐색 가능
    - 단점
        - 값을 중간에 삽입하면 그 값 뒤에 있는 값들 다 위치를 이동시켜야 함 (비효율적)

- ****Linked List****
    - 배열과 다르게 연속된 메모리 공간에 저장되어 있지 않음
    - 각각 데이터가 메모리 공간의 고유한 노드에 존재
    - 노드는 자신의 앞, 뒤에 있는 데이터의 주소를 알고 있음
    - 특정 데이터를 조사하려 하면 처음부터 순차적으로 탐색해야 함 → O(N)
    - 데이터 추가나 삭제는 O(1)
        - A B 사이에 F를 넣는다면 
        a에 저장한 b의 주소를 f로만 바꾸고 b에 저장한 a의 주소를 f로만 바꾸면 됨
    - 힙 영역에 메모리 할당
    - 장점
        - 주소가 연속되지 않아 값을 메모리 아무데나 둘 수 있음
        - 인덱스가 없고 현재 위치의 이전과 다음 주소를 기억하기 때문에
        데이터 삽입, 삭제가 쉽다.
    - 단점
        - 탐색이 느림
            - 연결되어 있는 링크를 따라가야함
    
    모든 원소의 값을 한 번에 읽어외야 한다면 연결 리스트, 특정 원소만 알고 싶으면 배열 사용
    

### 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.

---

https://think0wise.tistory.com/66

- 해시 테이블
    - Key, Value로 데이터를 저장하는 자료구조
    - key를 해시함수를 통해 해시값으로 바꾼다. → 해시값을 사용해 key-value로 저장
    - 순서가 없다.
    - 다른 자료구조에 비해 빠른 속도로 삽입, 삭제, 탐색 가능
    - 각각의 key값은 해시 함수에 의해 index를 가짐, 바로 접근 가능
     → 삽입, 삭제, 추가는 평균 O(1)의 시간복잡도
    - 다만 전부 충돌한 경우 O(n)일수도 → 해시함수의 의존도가 높다.

### BST(Binary Search Tree)와 Binary Tree에 대해 설명해주세요.

---

- 이진트리
    - 모드 노드들의 최대 자식노드 2개를 가진 트리
    - O(logN)

- 이진탐색트리
    - 왼쪽 자식은 루트보다 작고 오른쪽 자식은 루트보다 큰 이진 트리
    - 삽입, 삭제, 탐색과정에서 모두 트리의 높이만큼 탐색하기 때문에 O(logN)의 시간 복잡도
    - 전위순회, 중위순회, 후위순회

- 정이진트리 (**full binary tree)**
    - 모든 노드가 0개 또는 2개의 자식을 가진 트리

- **완전 이진트리(complete binary tree)**
    - 마지막 레벨을 제외하고 모든 레벨이 다 채워져 있는 트리

- 포화이진트리 **(Perfect Binary Tree)**
    
    정 이진트리 & 완전이진트리
    

- 편향 이진 탐색 트리
    - 왼쪽 또는 오른쪽 한쪽으로만 자식들을 가지고 있는 것
    - O(n)

[[CS - 자료구조] 이진 트리 (Binary Tree) 개념과 종류](https://velog.io/@dlgosla/CS-자료구조-이진-트리-Binary-Tree-vzdhb2sp)

### HashMap에서 key가 Int, Long등을 쓸 경우에 어떤 일이 일어나는지 설명해 주세요.

---

<자바>

- **HashMap**
    - **Key, Value를 저장하는 Map의 구현체 중 하나 (map자료 구조는 키를 통해 값을 접근할 수 있는 구조, 리스트나 배열은 인덱스로 접근)**
    - 키를 해싱함수에 넣음 → 인덱스를 얻음 → 그 인덱스를 버킷(배열) 안에 저장된 map 데이터에 저장
    - Key를 Hashing을 하여 저장하여 빠르게 처리, **입력과 삭제에 대해 시간복잡도가 O(1)**

<swift>

swift에선 해시맵이란 개념은 따로 없음

대신 키, 값을 사용하는 딕셔너리는 존재하고 딕셔너리와 사용자가 직접 해시함수를 구현해 
해시테이블은 구현 가능

```java
let hi: String = "안녕하세요"
let hello: String = "안녕하세요"
let apple: String = "애플사이다와 함께 하는 Swift 공부"

print(hi.hashValue)    // 2897817589225975386 - 해쉬값
print(hello.hashValue) // 2897817589225975386
print(apple.hashValue) // 1147360803777020165
```

콜렉션 타입(배열, 셋, 딕셔너리)는  Hashable 해야 한다는 개념은 존재함

셋 타입 모두 hashable하고 .hashValue로 해시값 접근 가능

a라는 변수가 사과, b라는 변수도 사과라는 string값을 담고 있다면 a, b는 동일한 해시값을 가짐

(같은 해시값이면 같은 value값을 가지고 있다는 말은 아님)

다만 컴파일할 때마다 해시값이 변경됨

### HashMap의 기본 동작인 put, get에 대해 각각 설명해 주시고, HashMap 동작 방식을 Object 클래스의 equlas(), hash() 메소드와 연관시켜 설명해 주세요.

---

<자바>

put을 통해 (키, 값)를 넣어주고값을 추가한다.

해시코드 = 각 개체가 갖는 유일한 값

equals 서로 같은 객체인지 판별

[[자료구조] 코드로 알아보는 java의 Hashmap](https://sabarada.tistory.com/57)
