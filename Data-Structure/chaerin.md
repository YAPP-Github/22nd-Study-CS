# Data Structure 질문

<details>
<summary>Table of Contents</summary>

- [4주차 기본](#4주차-기본)
- [optional 추가 질문](#optional-추가-질문)
</details>

## 4주차 기본
---
### Stack과 Queue의 실사용 예를 들어 간단히 설명해주세요.
---
#### stack

last in first out 후입선출
가장 최근에 추가된 데이터가 가장 먼저 꺼내진다.
정수기 종이컵 포개져있는 거 
함수 호출과 복귀, 실행 취소와 같은 기능에 사용
벡터를 상위 클래스로 받는다 
리스코프 치환 원칙 위반 사례로 아는 것

#### queue
first in first out 선입선출
가장 오래전에 추가된 데이터가 가장 먼저 꺼내진다.
은행 창구 
메시지 전송, 대기열등

---
### Array와 ArrayList의 차이점에 대해 설명해주세요.
---
공통: 둘다 데이터를 저장하고 관리하는 자료구조
#### 크기 제한
Array: 생성시 배열의 크기 고정, 변경 원하면 새로운 배열 생성해서 이전 데이터 복사
ArrayList: 크기 동적으로 조절 가능
#### 타입 제한
Array:  primitive+object
ArrayList: Object
하지만, primitive type의 저장은 불가해서 primitve type을 저장하면 자동으로 Object로 변경해 저장한다.

검색 속도 차이 없고 가변인자여서 배열의 1.5배씩 계속 커진다

---
### Array와 LinkedList의 장/단점에 대해 설명해주세요.
---
#### Array
장점:
빠른 인덱스 접근
단점:
크기 제한
데이터 삽입/삭제의 어려움 - 뒤에 있는 요소들도 단체 이동

#### LinkedList
장점:
동적 크기 조절
데이터 삽입/삭제의 용이함
단점:
접근의 어려움 - 순차적으로 탐색해야함
추가 메모리 공간 필요 - 다음 요소를 가리키는 링크를 위해

---
### 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.
---
키 값 구조로 데이터를 저장하는 자료구조
키를 해시함수에 넣어 반환된 해시 값을 테이블의 인덱스로 사용해 값을 저장
이때, 식별자인 해시 값을 인덱스로 갖는 배열을 버킷이라함
평균 O(1)의 시간 복잡도를 갖지만 다른 키 값에 대해 동일한 해시 값이 나올 경우 해시 충돌 발생
해시 충돌은 체이닝이라는 알고리즘으로 해결 가능
동일한 해시 값을 갖는 데이터들을 연결리스트 형식으로 연결하는 것으로 최악의 경우 시간 복잡도 O(N)

---
### BST(Binary Search Tree)와 Binary Tree에 대해 설명해주세요.
---
#### Binary Tree=이진트리
각 노드가 최대 두개의 자식 노드를 가지는 트리, 데이터를 계층적으로 저장하고 검색용

#### Binary Search Tree
이진트리의 일종으로 특정한 순서로 정렬된 자료구조
각 노드의 왼쪽 서브 트리에는 해당 노드보다 작은 값
각 노드의 오른쪽 서브 트리에는 해당 노드보다 큰 값
이진트리로 최대 2개 노드 갖는 거 동일
비교연산 수가 트리의 높이에 비례하므로 평균적으로 O(log n)의 시간 복잡도이나 불균형한 상태면 최악 O(N)

## optional 추가 질문
---
### HashMap에서 key가 Int, Long등을 쓸 경우에 어떤 일이 일어나는지 설명해 주세요.
---
Java에서 Int 객체(또는 Integer 객체)의 hashCode() 메서드는 Int 값 자체를 기준으로 해시 값을 생성합니다.  
Int 값은 32비트로 표현되며, Integer 클래스의 hashCode() 메서드는 이 32비트 값을 그대로 반환합니다.  
즉, Int 값이 Integer 객체로 감싸진 경우에도 Integer 객체의 hashCode() 메서드는 Int 값 자체를 해시 코드로 사용합니다.  
Long 클래스는 Object 클래스에서 상속 받은 hashCode() 메서드를 오버라이딩하여 Long 객체의 값을 해시 코드로 변환합니다.  
Long 객체의 hashCode() 메서드는 Long 값에 대한 비트 연산(bit operation)을 통해 해시 값을 생성합니다.  

---
### HashMap의 기본 동작인 put, get에 대해 각각 설명해 주시고, HashMap 동작 방식을 Object 클래스의 equlas(), hash() 메소드와 연관시켜 설명해 주세요.
---
해시맵: 해싱된 맵(키값쌍)  
put을 통해 키값쌍을 저장하고 get을 통해 키값으로 값을 읽어온다.  
이때 동일한 객체인지 식별이 필요한데 hashCode함수와 equasl함수를 통해 같은 객체인지 판별  
해시 코드 함수는 객체의 메모리 주소 값을 활용해 해시 값 생성 후 반환(예외.스트링→문자열 값 활용해 해시 값 생성 및 반환)  
이때, 객체의 주소 값이 달라도 객체의 값이 같아 같은 객체로 판단해야될 경우 오브젝트 클래스의 해시코드 함수를 오버라이딩해 재정의 해줘야한다.  

이때 키값을 해시 함수를 통해 해시 값을 반환해 이 값으로 값을 저장하는데  
해시 맵에서는 오브젝트 클래스의 해시 코드함수를 사용한다.  

두 객체의 equals 메소드를 실행시킨 결과가 참이면 두 객체의 해시 코드는 반드시 같아야하지만  
해시코드가 같다고 해서 반드시 equals가 참이어야하는 건 아님  
