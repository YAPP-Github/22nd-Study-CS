# Operating System 질문

---

## [1주차] 프로세스

### 1. 프로세스와 스레드의 차이는 무엇인가요 ?

#### ❗️ Process 란 ?
: Process는 컴퓨터에서 연속적으로 실행되고 있는 프로그램을 의미한다. 또한, 프로그램이 각 할당된 Heap 메모리에 적재되어 실행되고 있는 인스턴스를 의미하기도 한다.

특징

서로 완벽한 독립 공간을 가지고 있어, 하나의 Process 종료되어도 다른 Process 에는 영향을 주지 않는다.

하나의 프로그램에 여러 Process를 생성할 수 있다.

프로세스는 병행 실행이 가능하다.
단, 병행 실행하기 위해선 프로세스간의 통신이 필요하다.

독립적으로 실행되기 때문에 동기화를 하지 않아도 된다.

#### ❗️ Thread 란 ?
: Thread는 하나의 Process에 실행되는 여러 흐름의 단위이다.Process내의 별도의 영역에 저장되고 Process와 다르게 Heap 영역이 아닌 Stack 영역에 할당된다.

특징

Thread는 본질적으로 Process에 속해있기 때문에 Thread 간의 자원 공유가 가능하다.

자원을 공유하면서 사용하므로 통신 비용이 절감하고 메모리가 효율적이다.

Process 비해 Context Swithing 비용이 적다.

단, 자원을 공유하기 때문에 공유자원을 관리해줘야 한다.(동기화 작업)
(만약 서로 다른 Thread 가 동시에 공유 자원에 접근하면 교착 상태(Deadlock) 에 빠질 수 있다.)

### 2. 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요 ?
:교착상태(Deadlock)란, 컴퓨터 시스템이나 다중 프로세스 시스템에서 두 개 이상의 프로세스가 자원을 점유한 상태에서 원하는 추가 자원을 얻지 못해 무한히 대기하고 있는 상태를 말합니다. 이 상태에서는 프로세스들이 진행되지 않고 멈춰있기 때문에 시스템의 작업 처리량이 감소하고, 리소스의 효율성이 떨어지게 됩니다.

교착상태가 발생하기 위해서는 다음과 같은 네 가지 필요조건이 동시에 충족되어야 합니다:

- 상호 배제(Mutual Exclusion)
: 한 자원은 한 번에 한 프로세스만이 사용할 수 있어야 합니다. 다른 프로세스가 자원을 요청하면 해당 자원을 사용하고 있는 프로세스는 반납해야 합니다.

- 점유 대기(Hold and Wait)
: 프로세스가 최소한 하나의 자원을 점유한 상태에서 다른 자원을 요청하고, 해당 자원을 얻기 위해 대기하고 있어야 합니다. 이때 프로세스는 이미 점유한 자원을 반납하지 않고 유지합니다.

- 비선점(No Preemption)
: 다른 프로세스에 할당된 자원은 해당 프로세스가 반납하기 전까지는 강제로 빼앗을 수 없어야 합니다. 즉, 프로세스가 자원을 스스로 반납하기 전까지 다른 프로세스는 해당 자원을 사용할 수 없습니다.

- 순환 대기(Circular Wait)
: 프로세스의 집합에서 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있어야 합니다. 즉, 각 프로세스는 다음 프로세스가 점유한 자원을 대기하고 있어야 합니다.

이 네 가지 조건이 모두 충족되면 교착상태가 발생할 수 있습니다. 따라서 교착상태를 방지하기 위해서는 이러한 필요조건 중 하나 이상을 제거하거나 조정해야 합니다.

### 3. 교착상태의 해결법은 무엇인가요 ?
- 예방(Prevention)
: 교착상태가 발생하는 필요조건 중 하나 이상을 제거하여 교착상태를 예방하는 방법입니다. 예를 들어, 점유 대기 조건을 방지하기 위해 프로세스가 실행되기 전에 필요한 모든 자원을 한 번에 요청하도록 하는 것이나, 순환 대기 조건을 방지하기 위해 자원에 고유한 번호를 할당하고 번호 순서에 따라 자원을 요청하도록 하는 등의 방법을 사용할 수 있습니다.

- 회피(Avoidance)
: 교착상태의 가능성을 사전에 파악하고 회피하는 방법입니다. 자원 할당 그래프를 통해 시스템의 상태를 모니터링하고, 교착상태의 가능성이 있는 경우에만 자원을 할당하는 방식입니다. 은행원 알고리즘이나 자원 할당 그래프 알고리즘이 회피 방법을 구현한 대표적인 알고리즘입니다.

- 탐지 및 복구(Detection and Recovery)
: 교착상태가 발생하면 그것을 탐지하고, 탐지된 교착상태를 해결하기 위해 복구하는 방법입니다. 탐지 알고리즘을 통해 교착상태를 식별하고, 교착상태가 발생했을 때는 해당 프로세스들 중 하나 이상을 중지하거나 자원을 선점하여 교착상태를 해제합니다.

- 무시(Ignorance)
: 교착상태가 매우 드물게 발생하고, 해결하기 위한 비용이나 시스템 성능 저하가 크지 않을 경우에는 교착상태를 무시하는 방법을 선택하기도 합니다. 이는 일부 시스템에서는 적용 가능하지만, 대부분의 시스템에서는 권장되지 않습니다.

### 4. 뮤텍스와 세마포어에 대해서 설명해 보시오.
: 뮤텍스는 스레드 자체에 공유자원에 대한 소유권을 부여하는 방식, 세마포어는 접근할 수 있는 스레드 수를 제한하는 것. 자세한 차이는 너무 많다..

### 5. 컨텍스트 스위칭이란 무엇인가요 ?
: Context Switching 이란 동시성 처리를 하기위해 하나의 프로세스 또는 스레드에서 빠르게 Context 를 변경하면서 여러가지 일을 처리하는거 처럼 보이게 하는 방식입니다.


### 6.경쟁 상태란 무엇인가요 ?
: 경쟁 상태란 동일한 공유자원에 동시에 2개 이상의 스레드가 접근하는 것을 말합니다. 이렇게 되면 Thread Safe 하지 못하고, 원치 않는 결과가 나올 수 있습니다. 

- 예, 하나의 쓰레드에서 공유자원을 읽고 있다고 가정하고, 동시에 다른 스레드가 값을 변경 시킬 경우 원치않는 결과 값이 나올수 있다.
- Thread Safe ?
: 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바르게 나오는 것입니다. 
해결 방법 : 공유 자원을 최소한으로 줄여 각각의 스레드에서만 접근할 수 있는 저장소를 사용해서 동시접근을 막는 방법이 있을거 같습니다.

### 7. Thread Pool 이란 ?
:: ThreadPool 이란 필요한 Thread의 개수를 미리 지정해서 사용하는 것으로 알고 있습니다. 만약에 스레드를 한개만 생성 했을 경우 새로운 스레드가 필요한 때 생성하고 필요하지 않을 때 제거해야해서 비용이 많이 듭니다. 하지만 스레드의 갯수를 미리 지정함으로써 생성 제거 비용을 없애기 위해 만들어 진것으로 알고 있습니다 .

### 8. N개의 CPU 코어가 있을 때, ThreadPool size를 어떻게 정하면 좋을지 자유롭게 설명해 주세요.
: 일반적으로 N개의 CPU 코어가 있을 때 ThreadPool의 사이즈도 N개로 지정하는 것이 가장 효율적으로 알고 있습니다. 하지만 실행시간이나 대기 시간이 긴 작업들이 많을 경우에는 작업이 계속해서 대기해야하기 때문에 N개보다 크게 잡는 것이 좋은거 같습니다.

---

## [2주차] 프로세스

### 프로세스 혹은 스레드의 동기화란 무엇인가요?
: 프로세스나 스레드의 동기화는 병행 실행되는 여러 개의 프로세스 또는 스레드 간에 데이터나 자원에 대한 접근을 조절하여 일관성과 안전성을 보장하는 메커니즘입니다. 동기화는 동시에 실행되는 여러 개의 프로세스나 스레드가 공유하는 데이터에 접근할 때 발생하는 문제를 해결하고, 데이터의 무결성을 유지하기 위해 사용됩니다.

방법 - 뮤텍스, 세마포어, synchronized



### 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?
: 가장 큰 차이점은 운영체제의 사용 유무 라고 할 수 있는데요. 사용자 수준의 스레드에 경우 운체제를 인식하지 못해 스레드에 대한 스케줄링과 관련된 결정을 응용 프로그램 내에서 수행해야하고  커널 수준의 스레드에 경우는 운영체제에서 제공하는 스레드 관련 기능을 사용할 수 있어 효과적인 스케줄링을 할 수 있습니다.

#### 동기화 오버헤드 ?
: 사용자 수준은 커널에 비해 상대적을 작다.
그래서 커널 수준의 스레드에서 시스템 호출이 자주 발생할 경우 성능 저하가 발생할 수 있습니다.

#### 블로킹
:  사용자 수준 스레드의 경우 전체 응용프로그램이 영향을 받을 수 있지만, 커널 수중의 스레드의 경우에는 운영체제에서 스케줄링을 관리하기 때문에 다른 스레드는 계속해서 실행됩니다. 

#### 멀티 코어 ? 
: 커널 스레드는 운영체제에서 스케줄링을 관리하기 떄문에 멀티코어 시스템에서 병렬 실행을 효과적으로 수행할 수 있는 반면, 사용자 수준의 스레드의 경우에는 직접 스케줄링을 구현해야하기 때문에 멀티코어 시스템에서 병렬 실행이 이루어지지 않을 수 있습니다.

#### 사용자 수준의 스레드에서 멀티코어 시스템에서 병렬처리하기 위한 방법은 ?
- 멀티스레딩
: 응용 프로그램 내에 여러개의 스레드를 만들어서 각각의 스레드에 다른 코어를 할당하는 방식

- 스레드 풀
: 스레드의 개수를 미리 고정해서 스레드 생성 비용과 제거 비용을 줄이는 방식


### CPU 스케줄링이란 무엇인가요?
: CPU 스케줄링은 운영체제가 여러 개의 프로세스 또는 스레드 중에서 CPU 자원을 할당하는 방법을 결정하는 것을 말합니다. 여러 개의 실행 가능한 프로세스나 스레드가 동시에 존재하면, CPU 스케줄러는 어떤 프로세스 또는 스레드가 CPU를 사용할 수 있는지, 얼마나 오랫동안 사용할 수 있는지, 어떤 순서로 실행할지 등을 결정합니다.


### CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?
- FCFS (First-Come, First-Served):
가장 간단한 스케줄링 알고리즘으로, 도착한 순서대로 프로세스를 실행하는 방식입니다. 먼저 도착한 프로세스가 CPU를 먼저 할당받으며, 실행이 완료될 때까지 계속 실행됩니다. 선입선출 방식으로 공정한 스케줄링을 제공하지만, 실행 시간이 긴 프로세스가 먼저 도착하면 평균 응답 시간이 길어질 수 있습니다.

- SJF (Shortest Job First):
실행 시간이 가장 짧은 프로세스에게 CPU를 할당하는 방식입니다. 실행 시간이 짧은 작업을 먼저 처리하여 평균 응답 시간을 최소화합니다. 하지만 프로세스의 실행 시간을 미리 알 수 없기 때문에 정확한 예측이 어렵고, 실행 시간을 추정해야하는 단점이 있습니다.

- Round Robin:
고정된 시간 슬라이스(Time Slice)를 정의하고, 각 프로세스는 할당된 시간 동안 CPU를 사용합니다. 할당된 시간이 지나면 다른 프로세스에게 CPU를 양도하고, 다음 순서에 다시 할당됩니다. 모든 프로세스는 동일한 시간을 가지고 CPU를 사용하므로 공정한 스케줄링을 제공합니다. 하지만 긴 작업이 짧은 작업을 기다려야하는 '문제'가 발생할 수 있습니다.

- Priority Scheduling:
각 프로세스에 우선순위를 부여하고, 우선순위가 높은 프로세스에게 CPU를 할당하는 방식입니다. 정적 우선순위와 동적 우선순위 방식이 있으며, 실행 우선순위를 조절하여 특정 작업의 우선 처리를 보장할 수 있습니다. 그러나 우선순위 역전과 같은 문제가 발생할 수 있으므로 적절한 우선순위 관리가 필요합니다.

### 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

먼저, 동기와 비동기는 작업의 완료를 기다리는 방식을 나타내고, 블로킹과 넌블로킹은 호출한 쪽이 작업의 완료를 기다리는 동안 다른 작업을 수행할 수 있는지 여부를 나타냅니다.

동기(Synchronous):
동기적인 작업은 호출된 함수 또는 작업이 완료될 때까지 대기하는 방식입니다. 

비동기(Asynchronous):
비동기적인 작업은 호출된 함수 또는 작업을 호출한 후에도 다른 작업을 수행할 수 있는 방식입니다.

블로킹(Blocking):
블로킹은 함수 또는 작업이 호출된 후에 반환될 때까지 호출한 쪽이 대기하는 것을 말합니다. 호출된 함수가 완료되기 전까지는 호출한 쪽이 일시 정지되어 다른 작업을 수행할 수 없습니다.

넌블로킹(Non-blocking):
넌블로킹은 함수 또는 작업이 호출된 후에도 호출한 쪽이 대기하지 않고 즉시 반환되는 것을 말합니다. 호출한 쪽은 작업이 완료될 때까지 대기하지 않고 다른 작업을 수행할 수 있습니다. 작업이 완료되었는지 여부는 호출한 쪽에서 확인하거나, 콜백 또는 이벤트 핸들러를 통해 알 수 있습니다.

---

## [3주차] 메모리

### 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.

- **코드(Code) 영역**
: 프로그램의 실행 코드가 저장되는 영역입니다. 이 영역은 프로그램의 명령어들이 메모리에 로드되고 실행되는 곳입니다.

- **데이터(Data) 영역**
: 전역 변수(Global variables)와 정적 변수(Static variables)가 저장되는 영역입니다. 이 영역은 프로그램이 시작될 때 초기화되며, 프로그램의 수명 동안 유지됩니다.

 - **힙(Heap) 영역**
 : 동적으로 할당되는 메모리가 저장되는 영역입니다. 힙 영역은 프로그래머가 직접 제어할 수 있는 메모리 공간으로, 메모리가 자동 해제되지 않아 직접 메모리 해제를 하거나 GC의 도움을 받아 메모리 해제를 해주어야 한다.(ex-object type (String))

- **스택(Stack) 영역**
: 지역 변수(Local variables)와 함수의 매개변수(Parameter)가 저장되는 영역입니다. (원시 타입이 저장되는 영역, Heap 영역에 생성된 object type에 데이터의 참조값이 저장)
함수가 호출될 때마다 스택에 새로운 프레임(Frame)이 생성되며, 함수가 종료되면 해당 프레임이 제거됩니다. 스택은 후입선출(LIFO, Last-In-First-Out) 구조를 가지고 있습니다.



### 메모리 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.

메모리 구조에서 CPU에서 가까운 순서로는 다음과 같은 순서로 나열할 수 있습니다:

 - **레지스터(Register)**
 : 레지스터는 CPU 내부에 위치하며, 가장 빠른 접근 시간을 가지는 메모리입니다. 레지스터는 CPU 명령어를 실행하거나 데이터를 일시적으로 저장하는 데 사용됩니다.

- **캐시(Cache)**
: 캐시는 CPU와 주 메모리(메인 메모리) 사이에 위치하며, CPU가 자주 사용하는 데이터나 명령어를 저장하는 데 사용됩니다. 캐시는 주 메모리에 비해 더 빠른 접근 시간을 가지므로 CPU의 성능을 향상시키는 역할을 합니다.

- **주 메모리(Main Memory)**
: 주 메모리는 프로세스에 할당되는 메모리로서, 코드, 데이터, 힙, 스택 등의 영역을 포함합니다. 주 메모리는 CPU가 직접 접근할 수 있는 메모리이지만, 레지스터와 캐시에 비해 상대적으로 느린 접근 시간을 가집니다.

- **보조 저장장치(Secondary Storage)**
: 보조 저장장치는 하드 디스크 드라이브(Hard Disk Drive, HDD)나 솔리드 스테이트 드라이브(Solid State Drive, SSD)와 같은 장치를 의미합니다. 보조 저장장치는 주 메모리보다 용량은 크지만, 상대적으로 접근 시간이 더 느립니다. 데이터의 영구 저장과 프로그램 실행 파일의 보관에 사용됩니다.

이렇게 CPU에서 가까운 순서로 메모리 구조를 나열하면, 접근 시간이 점점 느려지지만 저장 용량은 늘어남에 따라 데이터의 지속성이 보장됩니다.

### 10개의 정수를 저장하는 배열이 있고 이 배열에 있는 모든 정수의 합을 for문으로 구혔했을 때, CPU-RAM 사이의 상호 동작을 저수준에서 말씀해 주세요.

CPU-RAM 사이의 상호 동작을 저수준에서 설명하면 다음과 같습니다:

1. 프로그램이 CPU로부터 실행되면, CPU는 해당 명령어를 가져와서 실행합니다.
2. CPU는 배열의 첫 번째 원소인 정수를 메모리 주소로부터 RAM으로부터 요청합니다.
3. 메모리 컨트롤러는 CPU의 요청을 받고, 메모리 계층 구조에서 가장 빠른 계층에서 데이터를 찾습니다.
4. 만약 해당 데이터가 CPU 캐시에 이미 존재한다면, CPU는 캐시로부터 데이터를 읽어옵니다. 그렇지 않다면, 메모리 컨트롤러는 RAM에서 해당 데이터를 읽어와 CPU로 전송합니다.
5. CPU는 읽어온 데이터를 레지스터에 저장합니다.
6. CPU는 다음 배열 원소를 읽기 위해 반복문을 계속 실행하고, 이 과정을 배열의 모든 원소에 대해 반복합니다.
7. 모든 배열 원소에 대한 작업이 완료되면, CPU는 결과를 저장할 레지스터 또는 메모리 위치에 저장합니다.

8. 결과를 저장한 레지스터나 메모리 위치로부터 CPU는 결과를 읽어올 수 있습니다.

이러한 과정에서 CPU와 RAM 사이에서는 데이터의 읽기와 쓰기가 발생하며, 메모리 계층 구조에서 데이터의 캐싱과 전송이 일어납니다. 이를 통해 CPU는 RAM에 저장된 배열의 각 정수를 읽어와 연산을 수행하고, 최종적인 합계를 구합니다.

### 페이지와 세그멘테이션에 대해서 설명해 보시오.

페이지(Page)와 세그멘테이션(Segmentation)은 가상 메모리(Virtual Memory) 시스템에서 사용되는 메모리 관리 기법입니다.

페이지(Page):

페이지는 일정한 크기로 분할된 고정 크기의 블록으로 메모리를 관리하는 기법입니다.
가상 주소 공간과 물리적인 메모리 공간을 동일한 크기의 페이지로 나누어 매핑하기 때문에 내부 단편화가 일어날 수 있습니다. 예를 들어, 프로세스의 크기가 10 페이지이고 페이지 크기가 4KB인 경우, 마지막 페이지에는 4KB보다 작은 내용만 포함될 수 있으며 이로 인해 내부 단편화가 발생합니다.

세그멘테이션(Segmentation):

세그멘테이션은 프로세스를 논리적인 단위인 세그먼트(Segment)로 분할하여 관리하는 기법입니다.
세그먼트는 프로세스의 논리적인 단위로서 코드, 데이터, 스택 등과 같은 논리적인 부분으로 구성됩니다.
각 세그먼트는 서로 다른 크기를 가질 수 있기 때문에 외부 단편화가 발생할 수 있지만 메모리를 효율적으로 관리하고 가상 메모리를 지원하는 데 매우 유용합니다.



### 외부 단편화란? 내부 단편화란?

외부 단편화(External Fragmentation)와 내부 단편화(Internal Fragmentation)는 메모리 관리에서 발생하는 두 가지 현상을 나타냅니다.

외부 단편화(External Fragmentation):

외부 단편화는 메모리 공간 중에 프로세스들이 사용할 수 없는 작은 조각들이 흩어져 있는 상태를 말합니다. 주로 동적 메모리 할당이 반복되거나 메모리 공간의 할당과 해제가 빈번하게 일어날 때 발생합니다.
외부 단편화는 가용한 메모리 공간이 충분하지만 연속된 큰 블록으로 사용할 수 없어서 실제로는 메모리가 낭비되는 상황입니다.
외부 단편화를 해소하기 위해 메모리 관리 기법 중 하나인 메모리 압축(Memory Compaction)이 사용될 수 있습니다. 메모리 압축은 프로세스들을 한쪽으로 모으거나 조각들을 합치는 등의 방법을 사용하여 외부 단편화를 해소합니다.

내부 단편화(Internal Fragmentation):

내부 단편화는 프로세스가 할당받은 메모리 공간보다 실제로 필요한 공간이 더 작은 상황을 말합니다. 주로 고정 크기의 메모리 블록을 사용하는 메모리 관리 기법에서 발생합니다.
내부 단편화는 프로세스가 사용할 수 있는 메모리 공간이 일부 낭비되는 상황입니다.
내부 단편화를 해소하기 위해 가변 크기 할당 방식을 사용할 수 있습니다. 가변 크기 할당 방식은 프로세스의 실제 크기에 맞게 메모리를 할당하므로 내부 단편화가 발생하지 않습니다.



### First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오.

First Fit, Best Fit, Worst Fit은 메모리 할당 알고리즘 중에서 자주 사용되는 세 가지 방식입니다. 이 알고리즘들은 프로세스가 메모리에 할당될 때 사용 가능한 공간을 찾는 방법에 차이가 있습니다.

- **First Fit**
: First Fit은 메모리에서 가장 먼저 발견된 충분한 크기의 공간에 프로세스를 할당하는 방식입니다.
메모리를 처음부터 순차적으로 검색하면서, 처음으로 발견된 충분한 크기의 공간에 프로세스를 할당합니다.
First Fit은 빠르게 실행되며, 메모리 내의 공간을 최대한 빨리 활용할 수 있습니다.
하지만 후에 발생할 수 있는 외부 단편화 문제가 있을 수 있습니다.
- **Best Fit**
: Best Fit은 가장 적합한 크기의 공간을 찾아서 프로세스를 할당하는 방식입니다.
메모리를 순차적으로 검색하면서, 가장 작은 크기의 충분한 공간을 찾습니다.
찾은 공간 중에서 가장 작은 크기의 공간을 사용하여 프로세스를 할당합니다.
Best Fit은 외부 단편화를 최소화하는 장점이 있지만, 검색 과정이 좀 더 오래 걸릴 수 있습니다.

- **Worst Fit**
: Worst Fit은 가장 큰 공간을 찾아서 프로세스를 할당하는 방식입니다.
메모리를 순차적으로 검색하면서, 가장 큰 크기의 충분한 공간을 찾습니다.
찾은 공간 중에서 가장 큰 크기의 공간을 사용하여 프로세스를 할당합니다.
Worst Fit은 외부 단편화를 최소화하는 장점이 있으며, 큰 프로세스를 처리하기에 유리합니다.
하지만 작은 공간이 남게되어 내부 단편화가 발생할 수 있습니다.
각 알고리즘은 자신의 장단점을 가지고 있으며, 메모리 할당 시 어떤 알고리즘을 사용할지는 메모리 사용 패턴이나 프로세스의 크기와 다른 요구사항에 따라 달라집니다. 성능과 메모리 활용의 균형을 고려하여 적절한 알고리즘을 선택해야 합니다.

### 페이지 교체 알고리즘 종류에는 어떤 것들이 있나요?

- **FIFO (First-In, First-Out)**
:FIFO 알고리즘은 가장 간단한 페이지 교체 알고리즘으로, 가장 먼저 들어온 페이지를 교체하는 방식입니다.
페이지의 도착 순서를 기준으로 페이지를 큐에 유지하고, 가장 먼저 도착한 페이지를 교체합니다.
FIFO 알고리즘은 구현이 간단하지만, 페이지의 접근 패턴에 따라 페이지 부재가 더 자주 발생하거나 교체 비용이 높아질 수 있습니다.
(FIFO 알고리즘은 페이지 참조 패턴이 지역성이 없는 경우에 사용될 수 있습니다. 모든 페이지를 동일한 확률로 접근하는 경우에는 FIFO 알고리즘이 적합합니다.)
- **LRU (Least Recently Used)**
: LRU 알고리즘은 페이지 중 가장 오랫동안 참조되지 않은 페이지를 교체하는 방식입니다.
페이지의 참조 시간을 기록하고, 가장 오래 전에 참조된 페이지를 교체합니다.
LRU 알고리즘은 페이지 교체의 최적해에 가까우며, 최근에 사용되지 않은 페이지를 교체하여 지역성(Locality)을 고려합니다.
하지만 구현이 복잡하고, 각 페이지에 대한 참조 시간을 추적해야 하므로 추가적인 비용이 발생할 수 있습니다.
(LRU 알고리즘은 페이지 참조 패턴에 기반하여 페이지를 교체하므로, 최근에 사용되지 않은 페이지를 교체하는데 효과적입니다. 캐시 메모리와 같이 자주 사용되는 데이터를 관리하는데 적합합니다.)
- **LFU (Least Frequently Used)**
: LFU 알고리즘은 페이지 중 가장 적게 참조된 페이지를 교체하는 방식입니다.
페이지의 참조 횟수를 기록하고, 가장 적게 참조된 페이지를 교체합니다.
LFU 알고리즘은 특정 페이지가 처음에 자주 참조되다가 후에 더 이상 사용되지 않을 경우에 효과적입니다.
하지만 페이지 참조 횟수를 추적하기 위해 추가적인 비용이 발생하고, 페이지 교체 정책이 지나치게 보수적일 수 있습니다.
(LFU 알고리즘은 특정 페이지가 초기에 자주 참조되다가 후에 더 이상 사용되지 않을 경우에 효과적입니다. 예를 들어, 네트워크 패킷 처리에서 사용되는 경우 특정 패킷이 일시적으로 많은 참조를 받다가 이후에 참조되지 않는 경우에 적용할 수 있습니다.)

- **Optimal**
: Optimal 알고리즘은 가장 이상적인 페이지 교체 알고리즘으로, 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체합니다.
모든 페이지에 대한 앞으로의 참조 패턴을 미리 알고 있어야 하며, 가장 최적의 페이지를 교체합니다.
(Optimal 알고리즘은 모든 페이지 참조 패턴을 미리 알고 있어야하므로, 시뮬레이션 및 성능 평가에 주로 사용됩니다. 이론적으로는 최적의 페이지 교체를 제공하지만, 실제로는 구현하기 어렵고 비용이 많이 듭니다.)
