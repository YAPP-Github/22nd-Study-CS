# Operating System 질문

<details>
<summary>Table of Contents</summary>

- [[1주차] 프로세스](##[1주차]-프로세스)
- [[2주차] 프로세스](##[2주차]-프로세스)
- [[3주차] 메모리](##[3주차]-메모리)

</details>


## [1주차] 프로세스
---
### 프로세스와 스레드의 차이는 무엇인가요?  
---
프로세스: 운영체제로부터 자원을 할당받는 작업의 단위로 최소 하나의 스레드 보유  
운영체제로부터 프로세서, 필요한 주소 공간, 메모리 등 자원을 할당받음  

스레드: 프로세스 안에서 실행되는 흐름 단위, 다른 스레드와 자원을 공유  

프로세스와 스레드의 가장 큰 차이: 프로세스는 자원을 공유하지 않지만 스레드는 자원을 공유  
+) 프로그램: 어떤 작업을 위해 실행할 수 있는 파일  

---
### 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?
---
교착상태란: 두 개 이상의 프로세스가 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 서로의 작업이 끝나기만을 무한정 기다리며 둘다 작업을 계속 끝내지 못하는 상태  
즉, 서로 원하는 자원을 얻기 위해 무한정 기다리는 상태  

**<교착상태란 발생 조건 4가지>**  
4가지 조건이 동시에 성립해야 발생  
**1. 상호배제 (Mutual Exclusion)**  
자원은 한 번에 하나의 프로세스에서만 사용 가능  
**2. 점유대기 (Hold and Wait)**  
최소한 하나의 자원을 점유한 상태에서 다른 자원을 할당받기 위해 대기  
**3.비선점 (Non Preemptive)**  
다른 프로세스에 할당돼있는 자원을 사용이 끝나기 전까지는 강제로 뺏을 수 없음  
**4.순환대기 (Circular wait)**  
각 프로세스가 순환적으로 요구하는 자원을 가지고 있음  
즉, 자원을 기다리는 프로세스 간에 자원을 요구하는 사이클 형성  

---
### 교착상태의 해결법은 무엇인가요?
---
**1. 데드락 예방 및 회피  
-데드락 예방**  

데드락에 빠지지 않도록 예방  
데드락 발생 조건 4가지 중 하나 이상을 부정하여 예방  

**1. 상호배제 (Mutual Exclusion) 부정**  
여러 프로세스가 자원을 동시에 사용  
→ 동기화가 불가능해 현실적으로 불가능  
**2. 점유대기 (Hold and Wait) 부정**  
프로세스가 실행 되기 전에 필요한 모든 자원을 할당   
→ 자원 낭비  
자원을 점유하고 있지 않을 때만 다른 자원 요청 가능하게  
→기아현상 발생 가능  
+기아현상: 한 놈이 계속 희생   
**3.비선점 (Non Preemptive) 부정**  
모든 자원에 대한 선점 허용(점유한 자원을 빼앗아 다른 프로세스에 제공)  
데드락을 예방하는 가장 현실적인 방안  
**4.순환대기 (Circular wait) 부정**  
일정 시간 자원을 받지 못하면 자원 요청을 취소하도록 함  
자원들에 일정한 순서를 부여하고 모든 프로세스들이 해당 순서대로 자원을 요청하도록 함  

**-데드락 회피**  

데드락이 발생하기 전에 데드락을 예상해 safe한 상태에서만 자원 요청을 허용  
데드락을 예상하고 파악하기 위해선 아래 가정들을 만족해야하는데 현실적으로 어려움  
프로세스 수 고정  
자원의 종류와 수 고정  
프로세스가 요구하는 자원 및 최대 자원의 수  
프로세스는 반드시 자원 사용 후 반납  
+unsafe 상태: 데드락이 될 수 있는 상태로 무조건 데드락 발생한다고 보장하진않음  

**2. 데드락 탐지 및 복구**  
데드락 탐지 알고리즘을 활용해 데드락이 발생했는지 탐지 후 발생했다면 복구  

**데드락 탐지 알고리즘의 종류**  
**-자원 할당 그래프 알고리즘(Resource Allocation Graph Algorithm)**  
시스템 내의 자원 할당 상황을 그래프로 모델링하여 데드락을 탐지하는 알고리즘  
사이클이 발생하면 데드락이 발생한 것   
**-점유 및 대기 알고리즘(Hold and Wait Algorithm)**  
시스템 내의 프로세스가 자원을 보유하고 있으면서 다른 자원을 대기하고 있는 상태를 탐지하는 알고리즘  
프로세스가 자원을 요청하면서 자원을 보유하고 있는 다른 프로세스에게서 요청한 자원이 대기 상태에 있으면 데드락이 발생한 것으로 판단  

**데드락 복구**  
**-프로세스 종료**  
모두 중지하거나 데드락이 사라질 때까지 한놈씩 중지  
**-자원 선점**  
데드락에 있는 프로세스가 점유하고 있는 자원을 선점하여 다른 프로세스에 할당  
최소의 피해를 줄 수 있는 선점할 프로세스 선택  
선점된 프로세스를 롤백해 데드락이 없던 이전 상태로 되돌림  
이때 기아 상태 방지 주의 →선점된 횟수에 따라 가중치를 부여해 우선 순위 조절을 통해 해결 가능  

**3. 데드락 무시**  
데드락을 해결하지 않고 무시  
데드락 발생 가능성이 희박한 시스템에서 사용  
데드락을 방지하고 탐지하는 것보다 무시가 더 효율적인 경우  

---
### 뮤텍스와 세마포어에 대해서 설명해 보시오.
---
둘다 상호배제를 달성하는 기법  
뮤텍스: 한 개의 쓰레드, 프로세스에 의해서만 소유될 수 있는 키 값을 기반으로한 상호배제기법   
세마포어: 현재 공유자원에 접근 가능한 쓰레드, 프로세스의 수를 통해 상호배제 달성  
사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용한 상호배제기법  

---
### 컨텍스트 스위칭이란 무엇인가요?
---
멀티 프로세스 환경에서 인터럽트 요청에 의해 다음 프로세스가 실행되어야할 때 기존에 실행 중이던 프로세스의 정보를 pcb에 저장하고 다음 프로세스의 정보를 pcb로부터 읽어 실행하는 작업  
+pcb(process control block): 프로세스의 context를 저장하는 곳으로 cpu가 해당 프로세스를 실행하기 위한 정보들을 담고있음  
+인터럽트 요청이 오는 상황들  
입출력 요청, cpu 사용시간 만료, 자식 프로세스 생성 등  

---
### 경쟁 상태란 무엇인가요? 
---
프로세스가 어떤 순서로 데이터에 접근하느냐에 따라 결과가 달라질 수 있는 상황  
둘 이상의 입력이나 조작이 일어나 의도치않은 결과가 발생하는 것  

## [2주차] 프로세스

---
### 프로세스 혹은 스레드의 동기화란 무엇인가요?
---
동기화: 공유자원의 일관성을 유지하는 것으로 컨텍스트 스위칭이 일어나는 상황에서 프로세스 혹은 스레드가 공유하는 자원의 일관성을 유지하는 것  
멀티 프로세스 혹은 쓰레드 환경에서 경쟁 상태가 발생하면 동시성 이유가 발생할 수 있으므로 이를 해결하기 위해 동기화가 필요  
가장 일반적인 방법은 상호배제로 한 번에 한 프로세스나 스레드만 공유 자원에 접근 가능한 메커니즘   

---
### 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?
---
생성 및 관리 주체의 차이!  
커널 수준 스레드: 커널 레벨에서 생성되는 스레드  
커널레벨에서 관리  
장점:  
커널이 직접 관리하며 다양한 기능 제공 및 안정성  
단점:   
유저모드에서 커널모드로의 전환이 필요해 성능 저하  

사용자 수준 스레드: 사용자가 스레드 관련 라이브러리로 구현하는 스레드  
응용 프로그램 수준에서 관리  
os에 의해 인식되지 않으며 os 스케줄러에 의해 관리 x  
따라서, 스레드의 생성, 스케줄링 ,동기화와 같은 기능이 응용프로그램에서 구현돼야함  
장점: 
스레드 컨텍스트 스위칭이 빠르다.  
유연성이 높다  
os의 개입없이 동작하므로 성능 최적화 가능  
단점:  
하나의 프로세스로부터 할당된 멀티 스레드 중 하나의 스레드가 대기 상태에 들어가면 다른 스레드도 실행 불가  

---
### CPU 스케줄링이란 무엇인가요?
---
다중 프로세스 환경에서 CPU 이용률을 높이고 한정된 자원을 공정하게 할당하기 위해 CPU를 어떤 순서로 할당할지 결정하는 것  
프로세스들이 CPU를 사용할 수 있는 시간과 순서를 결정하여 프로세스간 경쟁 상태를 해결  
최신 운영체제에는 실질적으로 프로세스가 아니라 커널 수준 스레드를 스케줄링  

---
### CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?
---
-선입선출:  
먼저 요청온 순서대로 프로세스에 CPU 할당  
-최단 작업 우선:  
실행 시간이 짧은 프로세스부터 우선적으로 CPU 할당,  
이를 위해 실행 시간 예측이 필요하다는 단점  
-우선순위:  
프로세스마다 우선순위를 부여하여 우선순위가 높은 프로세스부터 CPU 할당  
계속 우선순위가 낮은 프로세스 기아 상태 문제 발생  
→ aging을 활용해 대기한 시간에 따라 우선순위를 점진적으로 증가시켜 해결  
-라운드로빈:  
각 프로세스에 동일한 시간을 할당하고 할당된 시간이 지나면 다음 프로세스로 넘어가는 방식  
-다단계 큐:  
프로세스들을 여러 개의 우선순위 큐로 나누어 관리하고  
각 큐에 다른 스케줄링 알고리즘을 적용  
다양한 프로세스 유형에 대해 적합한 스케줄링 방식을 적용할 수 있다는 장점  

---
### 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?
---
동기/비동기 → 호출된 함수의 작업 완료 여부를 신경쓰는지  
블로킹/넌블로킹 → 현재 작업이 block되는지 안되는지, 즉, 제어권을 넘기는지안넘기는지  
동기:  
호출된 작업이 완료될 때까지 대기하며 결과가 반환될 때까지 다음 코드로 안넘어가는 방식  
순차적, 직렬적  
비동기:  
호출된 작업이 완료되길 기다리지않고 다음 코드로 넘어가는 방식  
작업이 완료되면 결과를 처리하기 위해 이벤트 처리나 콜백 함수를 사용  
병렬적, 동시성  

블로킹:  
호출된 작업이 완료될 때까지 대기하는 동안 실행 흐름을 멈추는 방식  
제어권을 호출된 작업으로 넘김  
해당 작업이 완료될 때까지 다른 작업 수행 불가  
넌블로킹:  
호출된 작업이 완료될 때까지 대기하지 않고 다음 코드를 실행  
제어권을 호출한 작업에서 계속 가지고 있음  

## [3주차] 메모리
---
### 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.
---
코드, 데이터, 힙, 스택 영역  
코드:   
프로그래머가 작성한 프로그램 함수들의 코드가 기계어로 변환되어 저장된 공간  
컴파일 타임에 결정되며 주로 읽기 전용으로 런타임 중 코드 변경 x  

데이터:  
전역 변수와 정적 변수 등 프로그램이 사용하는 데이터 저장 공간  
컴파일 타임에 해당 데이터를 참조하는 코드가 데이터 영역 주소값을 가르키도록 설정됨  
런타임 중 수정 가능  

힙:  
필요할 때마다 사용하는 메모리 영역으로 동적  
메모리 동적 할당시 사용  
런타임에 결정됨  

스택:  
지역 변수와 함수 호출에 관한 정보 임시 저장 영역  
호출된 함수의 수행을 마치고 복귀할 주소와 데이터 값들을 임시로 저장  

---
### 메모리 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.
---
레지스터→캐시→주기억장치→보조기억장치  
cpu에 가까울수록 처리 속도가 빠르나 가격이 비쌈  

레지스터:  
cpu 내부에 위치  
데이터와 명령어를 저장하는 역할을 하며, 가장 빠른 속도로 접근 가능한 메모리  

캐시:  
cpu가 자주 접근하는 데이터와 명령어를 저장하여 빠른 접근 제공  
속도와 용량에 따라 L1 캐시, L2 캐시, L3 캐시 등이 존재  

주기억장치(RAM):  
cpu나 메인보드에 위치하지않은 메모리 중 최상위 메모리  
프로그램의 실행에 필요한 모든 정보를 포함하며, 프로세스가 실행될 때 주 메모리로 로드  
cpu에 비해 속도가 느리지만 더 많은 데이터 저장 가능  

보조기억장치(HDD, SSD):  
주기억장치와 비교해 느리지만, 대용량 데이터 비휘발성 저장  
주기억장치에 로드된 데이터와 코드 중 일부는 필요에 따라 보조 저장 장치로 스왑되어 관리  

---
### 페이지와 세그멘테이션에 대해서 설명해 보시오.
---
연속 메모리 기법과 불연속 메모리 기법  
연속 메모리 기법: 프로그램이 연속적으로 이어진 공간에 할당되는 것  
불연속 메모리 기법: 프로그램이 서로 다른 주소 공간에 할당되는 것  

페이지와 세그멘테이션: 둘다 가상 메모리 시스템에서 사용되는 불연속 메모리 기법 

페이지:  
프로세스를 고정된 크기로 나누는 것  

세그멘테이션:  
논리적인 단위로 나누는 것  

---
### 외부 단편화란? 내부 단편화란?
--- 
둘 다 메모리 관리에서 발생하는 두 가지 종류의 낭비 현상  

외부 단편화:  
가변적으로 공간이 할당되다보면 메모리 공간을 분산된 형태로 할당하게 됨  
이때, 작은 메모리가 중간 중간 존재하며 메모리 공간 중 사용가능한 공간이 존재함에도 사용 불가한 상황이 생기는 문제 

내부 단편화:  
페이징 기법의 한계  
마지막 페이지 프레임을 다 채울 수 없어 메모리 낭비   

---
### First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오.
---
동적 메모리 할당 기법에 사용되는 알고리즘  

First Fit:  
메모리 공간을 순차적으로 검색하며, 처음으로 맞는 크기의 공간을 찾으면 할당  
간단하고 빠르지만 외부 단편화 발생 가능  

Best Fit:  
사용 가능한 메모리 공간 중에서 요청한 크기에 가장 근접한 작은 공간을 찾아 할당  
외부 단편화를 줄일 수 있지만 검색에 리소스 많이 필요  

Worst Fit:  
남은 공간 중 가장 큰 공간에 할당  
가장 큰 공간에 할당해서 가장 크게 남는 공간을 만들어야 다른 프로세스가 거기에 할당될 가능성이 높아짐 이용  
 
---
### 페이지 교체 알고리즘 종류에는 어떤 것들이 있나요?
---
FIFO (First-In, First-Out):  
가장 오래전에 메모리에 적재된 페이지를 교체하는 방식  
구현이 간단하지만 최근에 사용되었더라도 교체되는 단점 존재  

LRU (Least Recently Used):  
가장 오래 사용되지 않은 페이지를 교체하는 방식  
교체가 필요한 시점에 가장 오래전에 사용된 페이지를 교체  

LFU (Least Frequently Used):  
가장 적게 사용된 페이지를 교체하는 방식  
페이지의 사용 횟수를 카운트하고, 교체가 필요한 시점에 가장 적게 사용된 페이지를 교체  

OPT(Optimal):  
앞으로 가장 오랫동안 사용하지 않을 페이지를 교체  
모든 페이지 교체 알고리즘 중 page-fault 발생이 가장 적음  
실제 구현 거의 불가능  
