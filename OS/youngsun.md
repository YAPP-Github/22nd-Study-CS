# **Operating System 질문**

[TOC]



## **[1주차] 프로세스**



### 프로세스와 스레드의 차이는 무엇인가요?

------

프로세스란 .exe같은 아직 실행되지 않은 파일을 **프로그램**이라고 하는데 그 프로그램을 **실행**시키면 **프로세스**다.

즉 **컴퓨터에서 실행되고 있는 프로그램**이다.

**스레드**란 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위**이다.

둘의 큰 차이는 스레드는 **스레드끼리 메모리를 공유**하지만 프로세스는 **자신의 자원만 접근이 가능**하다.

따라서 한 스레드가 종료된다면 다른 스레드에게 영향을 끼치지만 프로세스는 한 프로세스가 종료되어도 다른 프로세스에게 영향을 끼치지 않는다.





### 교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?

------

교착상태란 프로세스 or 스레드들이 **서로 필요한 자원을 한정적으로 서로 가지고 있는 것이다.**

교착 상태 발생 조건은 4가지이고 모두 충족되어야 한다.

1. 상호 배제 (Mutual Exclusion)

- 한 번에 **한 개**의 프로세스만이 공유 자원을 사용할 수 있어야 함 -> 서로 lock을 사용할 수 있다는 말

1. 비선점 (Non-Preemptive)

- 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 **강제로 빼앗을 수 없어**야 함 -> 서로 lock을 사용할 수 있다는 말

1. 점유와 대기 (Hold & Wait)

- 최소한 **하나의 자원을 점유**하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 **대기하는 프로세스**가 있어야 함

1. 환형 대기 (Circular Wait)

- 공유 자원과 자원을 사용하기 위해 **대기**하는 프로세스들이 **원형**으로 구성되어 있어 **자신에게 할당된 자원을 점유**하면서 앞이나 뒤에 있는 프로세스의 **자원을 요구**해야 함



### 교착상태의 해결법은 무엇인가요?

------

**1. 예방**

- 교착상태가 발생하지 않도록 **사전에** 시스템을 제어하는 방법
- 앞서 살펴본 교착상태 발생의 **네 가지 조건 중 어느 하나를 제거**함으로써 수행

**1. 상호 배제 부정**

**여러 개의 프로세스가 동시에 공유자원을 사용할 수 있음**

**2. 점유 대기 부정**

**프로세스가 실행되기 전에 필요한 모든 자원을 할당하여 프로세스 대기를 없애거나, 자원이 점유되지 않은 상태에서만 자원 요청을 받도록 함**

**3. 비선점 부정**

**모든 자원에 대한 선점을 허용**

**4. 순환 대기 부정**

**자원을 선형으로 분류하여 고유 번호를 할당하고, 각 프로세스는 현재 점유한 자원의 고유번호보다 앞이나 뒤 한쪽 방향으로만 자원을 요구하도록 함**

- 자원의 **낭비**가 심한 기법

**2. 회피**

- 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 **적절히 피해**가는 방법
- 교착상태가 발생할 가능성이 있다면 자원 할당(Unsafe allocation)을 하지 않고 안전한 상태(Safe state)에서만 자원 요청을 허용하는 방법
- **Banker's Algorithm**이 사용

**3. 검출**

- 현재 **운영체제**는 이 검출방식으로 사용
- 시스템에 교착상태가 발생했는지 **점검**하여 교착상태에 있는 프로세스와 자원을 발견하는 것
- 그 중에는 **타임아웃**, 자원 할당 그래프 등을 사용할 수 있음

**4. 회복**

- 교착상태를 일으킨 **프로세스를 종료**시키거나, 교착상태의 **프로세스에 할당된 자원을 선점(preempt)**하여 프로세스나 자원을 회복하는 것



### 뮤텍스와 세마포어에 대해서 설명해 보시오.

------

- 공유된 자원에 여러 개의 프로세스가 **동시에** 접근할 때, 데이터를 **한 번에 하나의** 프로세스만 접근할 수 있도록 제한하도록 하는 도구이다.
- 뮤텍스는 동기화 대상이 **하나**이고, 상태가 0, 1 뿐이므로 **Lock**을 가질 수 있다,
- 세마포어는 동기화 대상이 **하나 이상**이고, **소유하지 않는 스레드**가 Semaphore를 **해제**할 수 있다.



### 컨텍스트 스위칭이란 무엇인가요?

------

- 왜 발생하는지? → 인터럽트
- 현재 작업하고 있는 프로세스를 교환하는 작업이다.
- **원래 실행하고 있던 프로세스**의 context를 **PCB라고 하는 별도의 메모리 공간에 저장** & **새로 실행할 프로세스**의 context를 **PCB에서 불러온다.**



### 경쟁 상태란 무엇인가요?

------

둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 **공유자원에 동시에 접근**하여 결과값에 영향을 줄 수 있는 상태이다.

ex) 은행에 10000원이 있을 때, 아들은 10000원을 출금하고 엄마는 아들에게 5000원을 입금함 → 0원 → 5000원이 되리라 예상 but 경쟁상태라면?

동시에 출금과 입금이 진행되는 경우

아들의 입장 : 현재잔고 10000원 – 10000원 출금 = 기대잔고 0원

엄마의 입장 : 현재잔고 10000원 – 5000원 입금 = 기대잔고 15000원

따라서 경쟁상태는 **공유 데이터(잔고)에 최종값을 보장할 수 없는 상황**을 말함





## [2주차] 프로세스



### 프로세스 혹은 스레드의 동기화란 무엇인가요?

------

- 동기화란?
  - 동기화 메커니즘은 **한 번에 하나의 스레드 또는 프로세스**만 공유 리소스에 액세스할 수 있도록 상호 배제를 적용하는 방법을 제공하는 것이다.
- 동기화를 해야하는 이유
  - 멀티 스레드인 경우 **서로 다른 쓰레드가 프로세스의 메모리를 공유하기 때문에** 동시에 자원에 접근하는 상황(**경쟁 상황**)이 생기게 되는데 이런 경쟁 상황으로 인해 발생하는 문제가 동기화 문제이다.
  - 이런 문제로부터 보호하기 위해 하나의 프로세스 혹은 하나의 쓰레드만이 한 자원에 접근할 수 있게 해야 한다.
- 동기화 방법
  - **Mutex(뮤텍스), Semaphore(세마포어)** 방법을 사용하여 해결할 수 있다. 간단하게 말하면 **뮤텍스**는 한 개의 쓰레드만 공유 자원에 접근할 수 있게 해서 경쟁 상황을 방지하는 것이고, **세마포어**는 지정한 수 만큼의 쓰레드만 공유 자원에 접근할 수 있게 하는 것이다.



### 사용자 수준의 스레드와 커널 수준의 스레드의 차이는 무엇인가요?

------

사용자 수준 스레드와 커널 수준 스레드는 **생성 주체가 누구냐**에 따라 구분

**사용자가 라이브러리를 통해 만들고 관리**하는 스레드가 **사용자 수준 스레드**이고, **OS의 커널이 만들고 관리**하는 스레드가 **커널 수준 스레드**



**사용자 수준 스레드**

- 사용자가 **스레드 관련 라이브러리로 구현해 사용하는 스레드**를 사용자 수준 스레드라고 한다.
- 스레드와 관련된 모든 행위를 **사용자 영역**에서 하기 때문에, **커널은 사용자 수준 스레드의 존재를 알지 못하고**, 스레드 교환에 개입하지 않는다.
- **사용자 수준 스레드 N개**가 **커널 수준 스레드 1개**에 매핑되므로, 다대일 스레드 매핑이라고 한다.

**장점**

- 커널에 **독립적**으로 스케줄링 할 수 있다 → **모든 운영체제에 적용**할 수 있다, 이식성이 높다.
- 스케줄링이나 동기화를 위해 커널을 호출x → **커널 영역으로 전환하는 오버헤드가 줄어든다**.
- 커널이 아닌 **스레드 라이브러리에서 스레드 스케줄링**을 제어 → 유연한 스케줄링이 가능하다.

**단점**

- 하나의 프로세스로부터 할당된 여러개의 스레드들 중, **한 스레드가 대기 상태**가 되면, 모든 스레드들을 실행시킬 수 없게 된다.
- **커널이 스레드 관리에 개입하지 않으므로**, 스레드 간 보호에 커널의 보호 방법을 사용할 수 없다. 라이브러리 수준의 보호 방법까지만 사용 가능하다.

핵심 키워드

- 커널이 사용자 수준 스레드를 알지 못한다
  - 장점: 스케줄링이나 동기화를 위해 커널을 호출하지 않는다 → 커널 영역으로 전환하는 오버헤드가 줄어든다.
  - 단점: 스레드 간 보호에 커널의 보호 방법을 사용할 수 없다.



**커널 수준 스레드**

**커널**이 **스레드와 관련된 모든 작업을 관리**하는 방식이다.

사용자 수준 스레드와 커널 수준 스레드가 **1대1로 매핑**된다.

**단점**

커널이 직접 스케줄링하고 실행하기 때문에 커널의 관리 지원을 많이 받을 수 있지만, 그 만큼 오버헤드가 늘어난다.

장점

커널이 각 스레드들을 개별적으로 관리할 수 있으므로, 동일한 프로세스에서 할당된 여러개의 스레드들 중 한 스레드가 대기상태가 되더라도, 다른 스레드들은 실행시킬 수 있다.

핵심 키워드

- <커널>이 스레드와 관련된 모든 작업을 관리



### CPU 스케줄링이란 무엇인가요?

------

여러 프로세스나 스레드가 CPU 시간을 놓고 경쟁하는 멀티태스킹 환경에서 CPU 스케줄링은 CPU를 효율적으로 활용하기 위해 **언제 어떤 프로세스에 CPU를 할당할지 결정하는 작업**이다.

**nonpreemptive(비선점형)**

- 강제로 빼앗지 않고 자진 반납

**preemptive(선점형)**

- 강제로 빼앗음

스케줄링 성능 평가



**CPU utilization (이용률)**

- 전체 시간 중에서 **CPU가 일을 한 시간의 비율**
- keep the CPU as busy as possible

**Throughput (처리량)**

- 주어진 시간동안 **준비 큐에서 기다리고 있는 프로세스** 중 **몇 개를 끝마쳤는지** 나타냄
- 즉 CPU의 서비스를 원하는 프로세스 중 몇 개가 원하는 만큼의 CPU를 사용하고 이번 CPU 버스트를 끝내어 준비 큐를 떠났지 측정한 것
- 더 많은 프로세스들이 CPU 작업을 완료하기 위해서는 CPU 버스트가 짧은 프로세스에게 우선적으로 CPU를 할당하는 것이 유리
- number of processes that complete their execution per time until

**Turnaround time (소요 시간, 반환 시간)**

- 프로세스가 CPU를 요**청한 시점부터 자신이 원하는 만큼 CPU를 다 쓰고 CPU 버스트가 끝날 때까지 걸린 시간**
- (준비 큐에서 **기다린** 시간) + (실제로 CPU를 **사용**한 시간)
- amount of time to execute a particular process

**Waiting time (대기 시간)**

- CPU 버스트 기간 중 프로세스가 준비 큐에서 **CPU를 얻기 위해 기다린 시간의 합**을 뜻한다.
- 시분할 시스템의 경우, 한 번의 CPU 버스트 중에도 준비 큐에서 기다린 시간이 여러 번 발생할 수 있다.
- 이때 대기 시간은 CPU 버스트가 끝나기까지 준비 큐에서 기다린 시간의 합을 뜻하게 된다.
- amount of time a process has been waiting in the ready queue

**Response time (응답 시간)**

- 프로세스가 **준비 큐에 들어온 후** **첫 번째 CPU를 획득하기까지 기다린 시간**을 뜻한다.
- 응답 시간은 대화형 시스템에 적합한 성능 척도로서, 사용자 입장에서 가장 중요한 성능 척도라고 할 수 있다.



### CPU 스케줄링 방법에는 대표적으로 어떤 것들이 있나요?

------

**FCFS (First-Come First-Served)**

- **비선점형** 스케쥴링
- **먼저** 온 순서대로 처리하는 스케줄링
- CPU를 오래 쓰는 프로세스가 먼저 와서 CPU를 할당 받으면, 나머지 프로세스들은 전부 기다려야하므로 **효율적이지 않음**

------

**SJF (Shortest-Job-First)**

- SJF는 CPU 버스트가 **가장 짧은 프로세스**에게 제일 **먼저** CPU를 할당하는 방식
- 평균 대기 시간을 **가장 짧게 하는** 최적 알고리즘

두 가지 방식

- nonpreemptive (비선점형)
  - 일단 CPU를 잡으면 더 짧은 프로세스가 들어와도 CPU 버스트가 완료될 때까지 CPU를 **선점당하지** 않음
- preemptive (선점형)
  - **SRTF (Shortest-Remaining-Time-First)**
  - CPU를 잡았다 하더라도 더 짧은 프로세스가 들어오면 CPU를 **빼앗김**

문제점

- **Starvation (기아)**
  - 짧은 프로세스로 인해 **긴 프로세스가 영원히** CPU를 잡지 못할 수 있음
- **CPU 버스트 시간**을 미리 알 수 없음
  - 과거 CPU 사용 시간을 통해 추정만 가능

------

**우선 순위 스케줄링 (Priority Scheduling)**

- 우선 순위가 **제일 높은** 프로세스에게 CPU를 할당
- 일반적으로 우선 순위 값 (priority number)가 **작을 수록 높은 우선 순위**

두 가지 방식

- nonpreemptive (비선점형)
  - 일단 CPU를 잡으면 더 높은 우선 순위를 가진 프로세스가 들어와도 CPU 버스트가 완료될 때까지 CPU를 **선점당하지 않음**
- preemptive (선점형)
  - CPU를 잡았다 하더라도 더 높은 우선 순위를 가진 프로세스가 들어오면 CPU를 **빼앗김**
- SJF는 일종의 **우선 순위 스케줄링**이라고 볼 수 있음 (우선 순위 = 예상되는 다음 CPU 버스트 시간)

문제점

- **Starvation (기아)**: 우선 순위가 **낮은** 프로세스는 영원히 CPU를 잡지 못할 수 있음

해결 방안

- **Aging (노화)**: 아무리 우선 순위가 낮은 프로세스라 하더라도 **시간이 오래 지나면** 우선 순위를 **높여주는** 기법

------

**Round Robin (RR)**

- **선점형 스케줄링**
- 각 프로세스는 동일한 크기의 할당 시간인 `time quantum` 을 가짐
- 할당 시간이 지나면 프로세스는 CPU를 빼앗기고 Ready Queue **맨 뒤**에 가서 줄을 서게 됨
- **짧은 응답 시간**을 보장함
  - 조금씩 CPU를 줬다 뺏었다를 반복하기 때문에 CPU를 최초로 얻기까지 걸리는 시간이 짧음
- 성능
  - q가 **커질 수록** FCFS에 가까워짐
  - q가 **작을 수록** context switch 오버헤드가 증가함
- 일반적으로 SJF보다 **평균 turnaround time(소요 시간)**이 길지만, **응답 시간**은 짧음
- 시간이 오래 걸리는 job과 짧게 걸리는 job이 **섞여 있을 때는 효율적**이지만, 모든 시간이 동일한 job만 있을 때는 비효율적



### 동기와 비동기, 블로킹과 넌블로킹의 차이는 무엇인가요?

------

**Blocking(블로킹)과 Non-blocking(논블로킹)**

- A 함수가 B 함수를 호출했을 때, **제어권을 어떻게 처리하느냐에 따라 달라진다.**
- 제어권
  - 제어권은 자신(함수)의 코드를 실행할 권리 같은 것이다. 제어권을 가진 함수는 **자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.**

1. 블로킹

**블로킹**은 A 함수가 B 함수를 호출하면, **제어권을 A가 호출한 B 함수에 넘겨준다.**

1. 논블로킹

**논블로킹**은 A함수가 B함수를 호출해도 **제어권은 그대로 자신이 가지고 있는다**.

------

**Synchronous(동기)와 Asynchronous(비동기)**

- 동기와 비동기의 차이는 **호출되는 함수의 작업 완료 여부를 신경쓰는지의 여부**의 차이이다.

1. 동기

함수 A가 함수 B를 호출한 뒤, **함수 B의 리턴값을 계속 확인하면서 신경쓰는 것**이 동기이다.

1. 비동기

함수 A가 함수 B를 호출할 때 **콜백 함수를 함께 전달**해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다.

함수 A는 함수 B를 호출한 후로 **함수 B의 작업 완료 여부에는 신경쓰지 않는다.**



## **[3주차] 메모리**



### 프로세스에 할당되는 메모리의 각 영역에 대해서 설명해 주세요.

------

**code 영역**

사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간

컴파일(compile) 타임에 결정되고 중간에 코드를 바꿀 수 없게 **Read-Only** 로 되어있다.

**data 영역**

전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장하는 공간

전역 변수또는static 값을 참조한 코드는 컴파일이 완료되면 data 영역의 주소값을 가르키도록 바뀐다. 전역변수가 변경 될 수도 있어 **Read-Write**로 되어있다.

**stack 영역**

호출된 함수의 수행을 마치고 **복귀할 주소** 및 **데이터**(지역변수, 매개변수, 리턴값 등)를 임시로 저장하는 공간

**heap 영역**

프로그래머가 필요할 때마다 사용하는 메모리 영역

heap 영역은 런타임에 결정된다.



### 메모리 구조의 순서가 어떻게 되는가? CPU에서 가까운 순으로 말해보시오.

------

레지스터 -> 캐시 메모리 -> 메인메모리 -> 보조기억장치 -> 외부기억장치 순으로 CPU와 멀어진다.

레지스터

- CPU 내부에 있는 가장 가까운 메모리 공간
- 명령어 실행에 필요한 데이터나 연산 결과를 일시적으로 저장
- 매우 빠른 속도로 접근할 수 있다.

캐시 메모리 (Cache Memory)

- 레지스터와 주 메모리 사이의 속도 차이를 완화하기 위한 목적으로 사용
- 레지스터보다는 느리지만, 주 메모리에 비해 상대적으로 빠르게 접근할 수 있다.

주 메모리 (Main Memory)

- 프로그램이 실행되는 동안 데이터와 명령어를 저장하는 메모리 공간
- 캐시 메모리에 비해 접근 속도가 느리다.

보조 저장 장치 (Secondary Storage)

- 하드 드라이브, SSD (Solid State Drive) 등의 장치
- 주 메모리와 비교했을 때 접근 속도가 상대적으로 느림 & 대용량의 데이터를 영구적으로 저장

CPU로부터 멀어질수록 데이터를 저장하는 용량이 커지고 접근 속도는 느려진다.



### 페이지와 세그멘테이션에 대해서 설명해 보시오.

------

페이징, 세그멘테이션 둘 다 가상 메모리 관리 기법이다.

***\*페이징(Paging)\****

- 프로세스의 주소 공간을 **동일한 크기**의 페이지 단위로 나누어 물리적 메모리의 **서로 다른 위치**에 페이지를 저장하는 방식
- **페이지 테이블**을 사용하여 **논리적 주소를 물리적 주소로 변환**하는 작업이 필요
- 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없으므로 프로세스의 주소 공간 중 **제일 마지막**에 위치한 페이지에서는 내부 조각이 발생할 수 있음

***\*세그멘테이션(Segmentation)\****

- 프로세스를 서로 **크기가 다른** 논리적인 블록 단위인 **세그먼트(Segment)**로 분할하여 메모리에 할당
- 세그먼트들의 크기가 서로 다르기 때문에 프로세스가 메모리에 적재될 때 **빈 공간**을 찾아 할당하는 기법
- 페이징과 마찬가지로 mapping을 위한 **segment table** 필요

단점

- **프로세스가 필요한 메모리 공간만큼 메모리를 할당해주기 때문에 내부 단편화 문제는 발생x but  중간에 메모리를 해제하면 생기는 외부 단편화 문제가 발생**

**Paging vs Segmentation**

- Paging은 **고정 크기**를 가짐
- Segmentation은 **가변 크기**를 가짐
- Paging은 **내부 단편화** 발생 가능, Segmentation은 **외부 단편화** 발생 가능



### 외부 단편화란? 내부 단편화란?

------

**내부 단편화(interner fragment)**

- 주기억장치 내 사용자 영역이 실행 프로그램보다 커서 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상

**외부 단편화 (External Fragment)**

- 외부 단편화란 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적(contiguous)이지 않아 발생하는 현상
- 압축 기법으로 해결 → 분산되어 있는 단편화된 공간들을 통합하여 **하나의 커다란 빈 공간을 만드는 작업**



### First Fit, Best Fit, Worst Fit에 대해서 설명해 보시오.

------

- **가변 분할 방식**에서 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내의 가용 공간 중 **어떤 위치에 올릴 것인지** 결정하는 문제 → **동적 메모리 할당 문제를 해결하는 방법 3가지**

First-fit

- size가 **n 이상인 것 중 최초**로 찾아지는 hole에 할당

Best-fit

- size가 **n 이상인 가장 작은 hole**을 찾아서 할당
- Hole들의 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole을 탐색해야 함

Worst-fit

- **가장 큰 hole**에 할당
- 역시 hole을 탐색해야 함
- 상대적으로 아주 큰 hole이 생성

**First-fit**과 **Best-fit**이 **Worst-fit**보다 속도와 공간 이용률 측면에서 효과적이다.



### 페이지 교체 알고리즘 종류에는 어떤 것들이 있나요?

------

- 페이지 교체를 할 때에 **어떠한 프레임에 있는 페이지를 쫓아낼 것인지** 결정하는 알고리즘



**최적 페이지 교체 (Optimal Algorithm)**

- 물리적 메모리에 존재하는 페이지 중 **가장 먼 미래에 참조될 페이지**를 쫓아내는 알고리즘
- 미래의 참조를 알아야 하므로 **오프라인**에서만 사용

**선입 선출 알고리즘 (FIFO Algorithm)**

- 물리적 메모리에 **가장 먼저 올라온 페이지**를 우선적으로 내쫓는 알고리즘
- 메모리를 증가하였음에도 페이지 부재가 **오히려 늘어나는 현상**(FIFO의 이상 현상)이 발생할 수 있음
- 위 그림은 메모리 프레임 개수를 늘렸음에도 페이지 부재가 늘어난 현상의 예제

**LRU (Least Recently Used) 알고리즘**

- **가장 오래 전에 참조가 이루어진 페이지**를 쫓아내는 알고리즘

**LFU (Least Frequently Used) 알고리즘**

- 페이지의 **참조 횟수가 가장 적은 페이지**를 교체하는 알고리즘