## 5주차


### OSI 7계층에 대해서 설명해주세요.

OSI(Open Systems Interconnection) 7계층은 컴퓨터 네트워크에서 데이터 통신을 위해 사용되는 프로토콜 스택을 기반으로 한 참조 모델입니다. 

- 물리 계층(Physical Layer)
: 네트워크의 물리적인 연결과 관련된 계층입니다. 비트 단위의 데이터를 전송하고, 전압, 전류, 케이블, 무선 등과 같은 물리적 매체를 다룹니다.

- 데이터 링크 계층(Data Link Layer)
: 물리 계층에서 전송된 데이터를 프레임으로 분할하고, 오류 검출 및 수정을 수행합니다. MAC(Media Access Control) 주소를 사용하여 네트워크 장치를 식별합니다.

- 네트워크 계층(Network Layer)
: 패킷을 이동시키고 목적지까지의 경로 선택과 라우팅을 수행합니다. 라우터가 이 계층에서 동작하며, IP(Internet Protocol) 주소를 사용하여 패킷을 전달합니다.

- 전송 계층(Transport Layer)
: 호스트 간의 신뢰성 있는 데이터 전송을 담당합니다. 데이터의 세그먼트화, 오류 제어, 흐름 제어, 재전송 등의 기능을 제공합니다. TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)가 이 계층에서 동작합니다.

- 세션 계층(Session Layer)
: 통신 세션을 설정, 유지, 종료하는 역할을 합니다. 세션 계층은 동기화, 대화 관리, 체크 포인트 등의 기능을 제공합니다.

- 표현 계층(Presentation Layer)
: 데이터를 애플리케이션에 맞는 형식으로 변환하고, 암호화, 압축, 인코딩, 형식 변환 등의 작업을 수행합니다. 데이터의 표현 방식과 구조를 정의합니다.

- 응용 계층(Application Layer)
: 최종 사용자에게 네트워크 서비스를 제공합니다. 일반적으로 HTTP, FTP, SMTP, DNS 등과 같은 프로토콜이 이 계층에서 동작하며, 사용자

### TCP/IP 4계층에 대해서 설명해주세요.

TCP/IP 모델은 OSI 모델과는 다른 네트워크 프로토콜 아키텍처로, 인터넷 프로토콜 스위트의 기반이 됩니다. TCP/IP 모델은 4개의 계층으로 구성되어 있습니다.

- 네트워크 인터페이스 계층(Network Interface Layer) 또는 네트워크 접근 계층(Network Access Layer)
: 이 계층은 물리적인 네트워크와의 인터페이스를 제공하고, 데이터를 프레임으로 분할하고 전송합니다. 또한, 이 계층은 네트워크 카드, 이더넷 등과 같은 하드웨어 장치와 관련된 프로토콜을 다룹니다.

- 인터넷 계층(Internet Layer)
: 이 계층은 IP(Internet Protocol) 프로토콜을 기반으로 동작합니다. IP는 패킷을 송수신하고, 패킷의 경로 선택과 라우팅을 담당합니다. 또한, IP 주소를 사용하여 패킷을 목적지에 전달합니다.

- 전송 계층(Transport Layer)
: 이 계층에서는 TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)와 같은 프로토콜이 동작합니다. TCP는 신뢰성 있는 연결 기반의 데이터 전송을 담당하고, 데이터의 분할, 순서화, 오류 제어, 흐름 제어 등을 수행합니다. UDP는 비연결성이며, 데이터의 신뢰성보다는 속도와 간단함을 우선시하여 사용됩니다.

- 응용 계층(Application Layer)
: 이 계층은 최종 사용자에게 네트워크 서비스를 제공합니다. 응용 프로토콜(예: HTTP, FTP, SMTP, DNS)은 이 계층에서 동작하며, 데이터의 포맷과 규칙을 정의합니다. 이 계층은 사용자 애플리케이션과 네트워크 인프라 간의 상호작용을 담당합니다.

TCP/IP 모델은 OSI 모델과 다르게 계층의 수가 적고, 계층 간의 구분이 상대적으로 덜 엄격합니다.

### DNS가 무엇인가요?

: 인터넷으로 통신하기 위해서는 수신처의 IP 주소를 알고 있어야합니다. 하지만 IP를 기억하고 있는 것은 매우 어렵고 기록한다. 하더라도 무슨 IP 주소인지 매번 적어야할 것입니다. 그래서 나온게 DNS 라는 개념이고 DNS 는 Domain Name System의 약자로 도메인의 이름을 IP 주소로 변환하는 역할을 수행하는 시스템 입니다. 

DNS는 도메인 이름을 IP 주소로 매핑하는 분산 데이터베이스 시스템으로 동작합니다. 도메인 이름을 사용자가 입력하면, DNS 서버는 해당 도메인 이름에 대응하는 IP 주소를 찾아서 반환합니다. 이를 통해 사용자는 도메인 이름을 사용하여 웹 사이트에 접속하거나 이메일을 보낼 수 있습니다.

DNS는 계층적인 구조를 가지고 있습니다. 최상위 계층은 최상위 도메인(Top-Level Domain)으로, 예를 들어 ".com", ".net", ".org"와 같은 도메인들이 있습니다. 그 아래로는 도메인 계층 구조가 있으며, 도메인 이름은 오른쪽에서 왼쪽으로 점으로 구분되어 계층적으로 구성됩니다. 가장 오른쪽의 도메인은 최하위 도메인이며, DNS 서버는 계층을 따라 도메인 이름을 해석하여 IP 주소를 찾습니다.

DNS는 전 세계적으로 분산된 여러 DNS 서버들로 구성되어 있습니다. DNS 쿼리(Query)를 수행하는 클라이언트는 로컬 DNS 서버에 도메인 이름을 전달하고, 로컬 DNS 서버는 계층적인 구조를 따라 도메인 이름을 해석하기 위해 다른 DNS 서버들과 통신합니다. 최종적으로 IP 주소를 찾아서 클라이언트에게 반환하게 됩니다.

DNS는 인터넷의 핵심적인 서비스로, 도메인 이름을 사용하여 사용자들이 웹 사이트를 찾고 통신할 수 있도록 도와줍니다.

### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.

1. 사용자가 웹 브라우저나 애플리케이션을 통해 도메인 이름을 입력합니다. 예를 들어, "www.example.com"이라는 도메인 이름을 입력합니다.

2. 사용자의 컴퓨터는 우선 로컬 DNS 캐시에 저장된 IP 주소를 확인합니다. 로컬 DNS 캐시는 이전에 방문한 도메인 이름에 대한 IP 주소를 저장하여 다시 검색할 필요 없이 빠르게 액세스할 수 있도록 합니다.

3. 로컬 DNS 캐시에 해당 도메인의 IP 주소가 없거나 만료된 경우, 사용자의 컴퓨터는 사전에 설정된 기본 DNS 서버에 DNS 쿼리를 보냅니다. 일반적으로 ISP(Internet Service Provider)가 제공하는 DNS 서버를 사용합니다.

4. 기본 DNS 서버는 도메인 이름을 가지고 있는 최상위 도메인(Top-Level Domain) 서버에게 쿼리를 전달합니다. 예를 들어, ".com" 도메인을 처리하는 최상위 도메인 서버에게 쿼리를 전송합니다.

5. 최상위 도메인 서버는 도메인 이름에 해당하는 도메인 등록 정보를 가지고 있는 네임 서버(Name Server)의 주소를 반환합니다.

6. 기본 DNS 서버는 네임 서버에게 쿼리를 전송하여 도메인에 대한 IP 주소를 요청합니다.

7. 네임 서버는 해당 도메인에 대한 IP 주소를 가지고 있거나, 다른 네임 서버에게 쿼리를 전달하여 IP 주소를 찾습니다. 이 과정은 계층적인 구조를 따라 도메인 계층을 거슬러 올라가며 진행됩니다.

8. 최종적으로 도메인에 대한 IP 주소를 가지고 있는 네임 서버는 IP 주소를 기본 DNS 서버로 전송합니다.

9. 기본 DNS 서버는 IP 주소를 로컬 DNS 캐시에 저장하고, 사용자의 컴퓨터에 IP 주소를 반환합니다.

10. 사용자의 컴퓨터는 이제 도메인 이름 대신 IP 주소를 사용하여 원하는 웹 서버에 연결합니다. 이를 통해 웹 페이지를 요청하고, 서버는 해당 IP 주소에서 올바른 웹 페이지를 전송합니다.

## 7주차

### HTTP와 HTTPS 의 차이는 무엇인가요?

HTTP(HyperText Transfer Protocol)와 HTTPS(HyperText Transfer Protocol Secure)는 인터넷에서 데이터를 전송하는 데 사용되는 프로토콜입니다. 그러나 두 프로토콜은 데이터 전송 중 보안과 관련된 중요한 차이점이 있습니다.

- 보안
HTTP: 암호화되지 않은 텍스트 기반 프로토콜로, 데이터가 평문으로 전송됩니다. 이는 해커가 데이터를 도청하거나 변조할 수 있는 보안 취약점을 남깁니다.
HTTPS: SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 사용하여 통신을 암호화합니다. 따라서 데이터는 암호화되어 전송되므로 도청이나 데이터 변조를 어렵게 만듭니다. HTTPS는 인증서를 사용하여 서버의 신원을 확인하고 클라이언트와 서버 간의 보안 연결을 설정합니다.

- 포트 번호
HTTP: HTTP는 기본적으로 80번 포트를 사용합니다.
HTTPS: HTTPS는 기본적으로 443번 포트를 사용합니다.

- 인증서
HTTP: HTTP는 인증서를 사용하지 않습니다.
HTTPS: HTTPS는 인증서를 사용하여 웹 사이트의 신원을 확인합니다. 인증서는 신뢰할 수 있는 기관에 의해 발급되며, 웹 브라우저는 인증서를 통해 서버의 신원을 확인하고 사용자에게 안전한 연결임을 보장합니다.

- 검색 엔진 최적화:
HTTP: HTTP로 운영되는 웹 사이트는 검색 엔진 최적화(SEO)에서 이점을 얻을 수 있습니다.
HTTPS: HTTPS로 운영되는 웹 사이트는 검색 엔진에서 더 높은 우선 순위를 받을 수 있습니다. 또한, 웹 브라우저에서 보안 경고를 표시하지 않기 때문에 사용자들에게 신뢰성을 제공합니다.

요약하면, HTTP는 암호화되지 않은 프로토콜로 보안이 약하며, HTTPS는 암호화된 프로토콜로 보안이 강화되어 있습니다. HTTPS는 인증서를 사용하여 서버의 신원을 확인하고 데이터의 안전한 전송을 보장합니다. 따라서, 개인 정보, 로그인 정보, 결제 정보 등을 처리해야 하는 경우에는 HTTPS를 사용하는 것이 안전합니다.


### HTTPS가 동작하는 방식에 대해서 설명해 주세요.

- 클라이언트 요청:
클라이언트(일반적으로 웹 브라우저)가 HTTPS를 사용하여 서버에 요청합니다. URL의 시작 부분에 "https://"를 사용하여 암호화된 연결을 나타냅니다.

- 서버 인증:
서버는 클라이언트에게 인증서를 제공합니다. 인증서는 신뢰할 수 있는 기관(Certificate Authority)에 의해 서버의 신원을 확인하고 서명된 데이터로 구성됩니다. 클라이언트는 이 인증서를 검증하여 서버의 신원을 확인합니다.

- 암호화 키 교환:
클라이언트는 서버의 공개키를 사용하여 암호화된 세션 키를 생성합니다. 이 세션 키는 데이터를 암호화하고 해독하는 데 사용됩니다.

- 데이터 암호화:
클라이언트는 생성된 세션 키를 사용하여 요청 데이터를 암호화합니다. 이로 인해 데이터가 전송 중에 도청되어도 해독이 어려워집니다.

- 데이터 전송:
클라이언트로부터 암호화된 데이터를 서버로 전송합니다. 데이터는 중간에 있는 네트워크 장치에서 도청되어도 암호화되어 있으므로 내용이 보호됩니다.

- 데이터 해독:
서버는 비밀 세션 키를 사용하여 받은 암호화된 데이터를 해독합니다. 이로써 서버는 클라이언트의 요청을 이해하고 처리할 수 있습니다.

- 응답 암호화:
서버는 세션 키를 사용하여 응답 데이터를 암호화합니다. 이로써 응답 데이터는 암호화된 상태로 클라이언트에게 전송됩니다.

- 데이터 전송:
서버로부터 암호화된 응답 데이터가 클라이언트로 전송됩니다. 다시 한번, 데이터는 중간에 있는 네트워크 장치에서 도청되어도 암호화되어 있으므로 내용이 보호됩니다.

- 데이터 해독:
클라이언트는 비밀 세션 키를 사용하여 받은 암호화된 응답 데이터를 해독합니다. 이로써 클라이언트는 서버로부터 받은 응답을 이해하고 화면에 표시할 수 있습니다.

HTTPS는 암호화된 연결을 통해 데이터의 기밀성과 무결성을 보장하며, 클라이언트와 서버 간의 안전한 통신을 제공합니다.


### HTTP 1.0과 1.1의 2.0와 그 특징에 대해서 설명해 주세요.

HTTP 1.0:

HTTP 1.0은 초기 버전으로, 1996년에 도입되었습니다.
각각의 요청마다 새로운 TCP 연결을 설정하고, 요청이 완료되면 연결을 닫는 방식을 사용합니다.
간단하고 직관적인 프로토콜로, 기본 요청과 응답 구조를 가지고 있습니다.
지속적인 연결(Persistent Connection)을 지원하지 않아 매 요청마다 연결을 설정해야 하므로 오버헤드가 발생할 수 있습니다.
캐싱 기능이 제한적이어서 동일한 자원에 대한 반복적인 요청이 발생할 수 있습니다.

HTTP 1.1:

HTTP 1.1은 1997년에 도입되었고, 현재까지 가장 널리 사용되는 버전입니다.
재사용 가능한 연결(Keep-Alive) 기능을 도입하여, 단일 연결에서 여러 요청과 응답을 처리할 수 있습니다.
파이프라이닝(Pipelining)을 지원하여 여러 요청을 동시에 보낼 수 있어 처리 속도를 향상시킵니다.
가상 호스팅(Virtual Hosting)을 지원하여 하나의 서버에서 여러 도메인을 호스팅할 수 있습니다.
캐싱 기능이 개선되어 캐시 제어와 조건부 요청 등을 통해 효율성을 높였습니다.

HTTP 2.0:
HTTP 2.0은 2015년에 도입되었습니다.
이전 버전과 비교하여 성능과 효율성을 크게 개선했습니다.
이진 프레이밍(Binary Framing) 방식을 도입하여 헤더와 데이터를 압축하고 병렬로 전송할 수 있습니다.
서버 푸시(Server Push) 기능을 지원하여 클라이언트의 요청 없이 필요한 리소스를 미리 전송할 수 있습니다.
헤더 압축 기능을 통해 헤더 크기를 최소화하고 네트워크 대역폭을 절약합니다.
멀티플렉싱(Multiplexing)을 지원하여 여러 요청과 응답을 동시에 처리하며, 응답의 우선순위를 설정할 수 있습니다.
전송 오류 복구 기능을 강화하여 신뢰성을 높였습니다.
HTTP 2.0은 이전 버전들과 비교하여 성능과 효율성을 향상시키는 다양한 기능을 제공하므로, 현재 웹 서비스에서 널리 사용되고 있습니다.


### keep-alive 헤더에 대해서 설명해 주세요.

Keep-Alive 헤더는 HTTP 요청과 응답에서 사용되는 옵션 중 하나입니다. 이 헤더를 통해 클라이언트와 서버 사이의 TCP 연결을 재사용할 수 있습니다. 일반적으로 Keep-Alive 헤더는 HTTP 1.1 버전부터 지원됩니다.

HTTP 1.0에서는 매 요청마다 새로운 TCP 연결을 설정하고 요청이 완료되면 연결을 닫았습니다. 이로 인해 많은 네트워크 오버헤드가 발생하고, 요청마다 새로운 연결을 설정해야 했습니다.

하지만 Keep-Alive 헤더를 사용하면 단일 연결을 통해 여러 요청과 응답을 처리할 수 있습니다. 클라이언트는 Keep-Alive 헤더를 요청에 포함시켜 서버에 연결을 유지하도록 요청할 수 있고, 서버는 응답에 Keep-Alive 헤더를 포함시켜 연결을 유지하도록 알려줄 수 있습니다.

Keep-Alive 헤더에는 다음과 같은 정보가 포함될 수 있습니다:

Connection: Keep-Alive (클라이언트 요청에서 사용): 클라이언트가 서버에게 연결을 유지하도록 요청합니다.
Connection: close (서버 응답에서 사용): 서버가 연결을 닫으라고 클라이언트에게 알려줍니다.
Keep-Alive 헤더를 사용하면 다음과 같은 이점이 있습니다:

매 요청마다 TCP 연결을 설정할 필요가 없어지므로 네트워크 오버헤드가 감소합니다.
연결의 재사용으로 인해 요청의 응답 시간이 단축될 수 있습니다.
클라이언트와 서버 사이의 상태 유지가 가능해집니다.
TCP 연결의 유휴 시간을 조절할 수 있어서 네트워크 리소스를 효율적으로 사용할 수 있습니다.
Keep-Alive 헤더는 HTTP 요청과 응답에서 연결을 유지하고 재사용할 수 있는 기능을 제공하여 웹 페이지의 로딩 시간을 개선하고, 네트워크 리소스를 효율적으로 활용할 수 있도록 도와줍니다.

### HTTP GET과 POST의 차이는 무엇인가요?

HTTP GET과 POST는 HTTP 프로토콜에서 사용되는 두 가지 주요한 메서드(Method)입니다. 이 두 메서드는 다음과 같은 차이점이 있습니다:

- 목적
GET: GET 메서드는 서버로부터 데이터를 요청하기 위해 사용됩니다. 주로 정보의 조회나 검색과 같은 목적으로 사용됩니다. GET 요청은 서버에서 데이터를 읽어오는 용도로 사용됩니다.
POST: POST 메서드는 서버에 데이터를 제출하기 위해 사용됩니다. 주로 사용자 입력 데이터를 서버로 보내거나, 서버에 새로운 데이터를 생성하기 위해 사용됩니다. POST 요청은 서버에 데이터를 전송하여 처리하는 용도로 사용됩니다.

- 데이터 전송
GET: GET 메서드는 데이터를 URL의 쿼리 문자열(Query String)에 포함하여 전송합니다. 데이터는 URL 뒤에 ?를 사용하여 key-value 쌍의 형태로 전달됩니다. 예를 들어, https://example.com/search?keyword=apple과 같이 전달됩니다. 데이터의 길이에 제한이 있고, 보안이 취약할 수 있습니다.
POST: POST 메서드는 요청의 body에 데이터를 포함하여 전송합니다. 데이터는 헤더와 별도의 body 섹션에 포함되어 전달되며, 사용자에게 노출되지 않습니다. 데이터의 길이에 제한이 없고, 보안적인 측면에서 GET보다 안전합니다.

- 캐싱
GET: GET 요청은 캐싱이 가능합니다. 동일한 GET 요청을 반복해서 보낼 경우, 이전에 받은 응답을 캐시에서 가져올 수 있습니다. 따라서 GET 요청은 동일한 데이터를 반복해서 요청해도 일관된 결과를 얻을 수 있습니다.
POST: POST 요청은 기본적으로 캐싱되지 않습니다. 매번 서버로 요청을 전송하며, 서버는 매번 새로운 데이터를 처리합니다.
- 보안
GET: GET 요청은 URL에 데이터가 노출되기 때문에 보안에 취약합니다. URL은 브라우저 히스토리나 서버 로그 등에 저장될 수 있습니다. 따라서 GET 요청으로 민감한 정보를 전송하는 것은 적절하지 않습니다.
POST: POST 요청은 데이터가 URL에 노출되지 않기 때문에 GET보다 보안적으로 안전합니다. 데이터는 요청의 body에 포함되어 전송되므로 외부에서 쉽게 탈취하기 어렵습니다.
GET과 POST는 각각 다른 목적과 데이터 전송 방식을 가지고 있습니다. GET은 데이터를 조회하고 검색하는 용도로 사용되며, POST는 데이터를 제출하고 처리하는 용도로 사용됩니다. 이에 따라 데이터 전송 방식, 캐싱 기능, 보안 등에서 차이가 있습니다.

### 쿠키와 세션에 대해서 설명해 주세요.

쿠키와 세션은 웹 애플리케이션에서 상태 유지(Stateful)를 위해 사용되는 메커니즘입니다. 이 둘은 클라이언트와 서버 간의 상태 정보를 저장하고 전달하는 방식에 차이가 있습니다.

쿠키(Cookie):

쿠키는 클라이언트의 웹 브라우저에 저장되는 작은 데이터 조각입니다.
서버에서 클라이언트로 쿠키를 보내고, 클라이언트는 이를 브라우저에 저장합니다.
클라이언트가 동일한 서버에 재요청할 때마다 쿠키는 요청과 함께 서버로 전송됩니다.
주로 사용자 식별, 선호 설정, 장바구니 등을 유지하기 위해 사용됩니다.
클라이언트에서 쿠키를 제거하거나 만료시킬 때까지 지속됩니다.
세션(Session):

세션은 서버 측에서 관리되는 데이터 구조입니다.
클라이언트가 서버에 접속하면 서버는 고유한 세션 ID를 생성하고 클라이언트에게 제공합니다.
세션 ID는 일반적으로 쿠키를 사용하여 클라이언트에 저장됩니다. 하지만 URL 매개변수를 통해 전달되기도 합니다.
클라이언트는 요청을 보낼 때마다 세션 ID를 서버로 전달하여 세션을 식별합니다.
서버는 클라이언트의 세션 ID를 사용하여 세션 데이터를 찾고, 필요한 정보를 유지하고 공유합니다.
세션은 서버 측에서 유지되기 때문에 쿠키보다 보안적으로 안전합니다. 클라이언트에는 세션 데이터가 직접 저장되지 않습니다.
일반적으로 세션은 클라이언트가 브라우저를 종료하거나 세션 유효기간이 만료될 때까지 지속됩니다.
요약하면, 쿠키는 클라이언트 측에서 저장되는 데이터로서, 클라이언트와 서버 간의 상태 유지에 사용됩니다. 세션은 서버 측에서 관리되는 데이터로서, 클라이언트를 식별하고 클라이언트의 상태를 유지하기 위해 사용됩니다. 쿠키는 클라이언트에서 제어되며, 세션은 서버에서 제어됩니다.

## 8주차 
### TCP와 UDP의 차이에 대해서 설명해 주세요.
: TCP (Transmission Control Protocol)는 신뢰성과 순서 보장을 중시하는 연결 지향 프로토콜입니다. TCP는 데이터를 작은 패킷으로 나누어 전송하고, 수신 측에서는 이러한 패킷들을 재조립하여 완전한 데이터로 복구합니다. 이를 위해 각 패킷은 시퀀스 번호를 가지고 있어서 데이터의 순서를 추적할 수 있습니다. 또한, 수신 측에서는 패킷의 손실이나 오류를 감지하고 재전송을 요청할 수 있습니다. TCP는 신뢰성을 보장하기 위해 패킷 전송 확인, 패킷 재전송, 흐름 제어, 혼잡 제어 등의 기능을 제공합니다. 따라서, TCP는 웹 브라우징, 이메일, 파일 전송 등과 같이 신뢰성이 중요한 애플리케이션에서 주로 사용됩니다.

반면에 UDP (User Datagram Protocol)는 신뢰성이 낮지만 빠른 속도가 필요한 경우에 사용되는 비연결 지향 프로토콜입니다. UDP는 패킷을 단순히 보내고 받는 역할만 하며, 추가적인 기능을 제공하지 않습니다. 따라서, 데이터를 전송할 때 패킷의 손실이나 순서 변경이 발생할 수 있으며, 이러한 문제에 대한 보정은 애플리케이션에서 처리해야 합니다. UDP는 실시간 스트리밍, DNS 조회, 오디오/비디오 통화 등에서 주로 사용됩니다. 이러한 애플리케이션에서는 데이터의 신속한 전달이 중요하며, 약간의 패킷 손실이나 지연이 발생해도 문제가 크게 되지 않는 경우가 많습니다.

요약하자면, TCP는 신뢰성과 순서 보장을 중시하는 연결 지향 프로토콜이며, UDP는 신뢰성이 낮지만 빠른 속도가 필요한 비연결 지향 프로토콜입니다. TCP는 패킷의 전송 및 수신 확인, 재전송, 흐름 제어, 혼잡 제어 등의 기능을 제공하지만, UDP는 이러한 기능을 제공하지 않습니다. 따라서, 애플리케이션의 요구에 따라 TCP 또는 UDP를 선택하여 데이터를 전송할 수 있습니다.

### TCP 헤더에 대해서 설명해 주세요.
TCP 헤더는 TCP 프로토콜의 데이터 전송 과정에서 패킷에 추가되는 정보를 담고 있는 부분입니다. TCP 헤더는 20바이트로 구성되며, 다음과 같은 필드로 구성됩니다:

- 소스 포트(Source Port)
: 전송하는 응용 프로그램의 포트 번호를 나타냅니다. 이 값은 16비트로 표현되며, 송신 측의 응용 프로그램을 식별합니다.

- 목적지 포트(Destination Port)
: 수신측 응용 프로그램의 포트 번호를 나타냅니다. 이 값도 16비트로 표현되며, 수신 측의 응용 프로그램을 식별합니다.

- 시퀀스 번호(Sequence Number)
: TCP 세션에서 전송되는 데이터의 바이트 순서를 나타냅니다. 이 값을 사용하여 수신 측에서 데이터의 순서를 복구할 수 있습니다.

- 확인 응답 번호(Acknowledgment Number)
: 확인 응답(Acknowledgment)을 위해 사용되며, 수신 측이 다음에 기대하는 바이트를 알려줍니다. 이 값은 수신 측이 받은 데이터의 바이트 수에 1을 더한 값입니다.

- 헤더 길이(Header Length)
: TCP 헤더의 길이를 4바이트 단위로 표현한 값입니다. 예를 들어, 5는 헤더가 20바이트임을 나타냅니다.

- 플래그(Flags)
: TCP 통신의 상태와 제어 정보를 나타내는 비트 필드입니다. 주요 플래그로는 URG, ACK, PSH, RST, SYN, FIN 등이 있습니다. 예를 들어, SYN 플래그는 TCP 연결 설정을 시작하고, ACK 플래그는 수신 측으로부터 확인 응답을 나타냅니다.

- 창 크기(Window Size)
: 송신 측에서 수신 측에게 받을 수 있는 데이터의 양을 나타냅니다. 이 값은 수신 측의 버퍼 크기를 나타내며, 수신 측은 이를 기반으로 송신 측에게 데이터를 전송할 수 있는 윈도우 크기를 알려줍니다.

- 체크섬(Checksum)
: 데이터의 오류를 검출하기 위한 체크섬 값입니다. 송신 측에서 TCP 헤더와 데이터를 계산하여 체크섬을 생성하고, 수신 측에서는 체크섬을 검사하여 오류 여부를 확인합니다.

- 긴급 포인터(Urgent Pointer)
: URG 플래그가 설정된 경우, 긴급 데이터의 마지막 바이트 위치를 가리킵니다.

TCP 헤더는 데이터 전송의 제어 정보와 오류 검출을 위한 필수적인 정보를 포함하고 있습니다. 이를 통해 TCP는 신뢰성과 순서 보장을 실현할 수 있습니다.

### MTU가 무엇인가요?
: MTU는 Maximum Transmission Unit의 약자로, 네트워크 통신에서 한 번에 전송할 수 있는 최대 데이터 패킷 크기를 나타냅니다. MTU는 네트워크 링크(이더넷, Wi-Fi, PPP 등)에서 지원하는 최대 프레임 크기를 의미합니다.

MTU는 일반적으로 바이트 단위로 표현되며, 네트워크 링크의 종류에 따라 다양한 크기가 사용될 수 있습니다. 예를 들어, 이더넷의 MTU는 일반적으로 1500바이트입니다.

MTU의 중요한 역할은 큰 데이터를 작은 패킷으로 분할하여 전송할 때 발생하는 패킷 조각화(fragmentation)를 제어하는 것입니다. 네트워크 링크는 MTU보다 큰 데이터를 전송하기 위해 패킷을 작은 조각으로 분할하고, 수신 측에서는 조각화된 패킷을 재조립하여 원래의 데이터로 복원합니다. 그러나 패킷 조각화는 네트워크 성능을 저하시킬 수 있으므로, 가능한 경우 MTU에 맞는 크기로 데이터를 전송하는 것이 성능을 향상시키는 데 도움이 됩니다.

MTU 크기는 네트워크 트래픽의 효율성과 성능에 영향을 미칠 수 있습니다. 큰 MTU 크기는 대용량 데이터 전송 시간을 줄일 수 있지만, 패킷 손실이나 조각화 문제가 발생할 수 있습니다. 작은 MTU 크기는 패킷 조각화를 줄이고 안정성을 높일 수 있지만, 전송 효율성은 저하될 수 있어, 적절한 MTU 크기를 설정하는 것이 중요합니다.

### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요.
3-way handshake:

- 클라이언트(Client)는 서버(Server)에게 연결 요청을 보내기 위해 SYN(Synchronize) 패킷을 전송합니다. 이 패킷은 클라이언트가 서버와의 연결을 설정하고자 함을 나타냅니다. 

- 서버는 클라이언트의 요청을 수신했음을 알리기 위해 SYN-ACK(Synchronize-Acknowledgment) 패킷을 전송합니다. 이
패킷은 서버가 클라이언트의 요청을 받아들였으며, 클라이언트와의 연결 설정을 위한 초기 시퀀스 번호를 포함합니다.

- 클라이언트는 서버로부터의 응답을 확인하기 위해 ACK(Acknowledgment) 패킷을 전송합니다. 이 패킷은 서버로부터 받은 SYN-ACK 패킷에 대한 확인 응답이며, 서버와 클라이언트 간의 연결이 성공적으로 설정되었음을 나타냅니다.

4-way handshake:

- 클라이언트 또는 서버 중 한 쪽이 연결 종료를 요청하기 위해 FIN(Finish) 패킷을 전송합니다. 이 패킷은 상대방에게 연결 종료를 요청함을 알리는 역할을 합니다.
- 상대방은 FIN 패킷을 수신했다는 확인을 위해 ACK 패킷을 전송합니다. 이 패킷은 FIN 패킷에 대한 확인 응답입니다.

- 연결을 종료할 준비가 되었다는 신호로써, 연결을 종료하기 위해 자원을 정리하고 상태를 유지하는 시간을 대기하는 과정입니다.
- 정리 및 대기 과정이 완료되면, 상대방에게 FIN 패킷을 전송하여 연결을 종료함을 알립니다. 이에 대한 확인 응답으로 ACK 패킷이 전송됩니다.
이렇게 4-way handshake가 완료되면 클라이언트와 서버 간의 TCP 연결이 종료됩니다. 연결 종료 후에는 더 이상 데이터 전송이 이루어지지 않습니다. 4-way handshake는 양방향 통신이기 때문에 양쪽에서 동시에 종료 요청을 할 수도 있습니다.

3-way handshake는 연결 설정을 위해 3개의 패킷을 주고받는 과정이고, 4-way handshake는 연결 종료를 위해 4개의 패킷을 주고받는 과정입니다. 이러한 핸드셰이크 과정을 통해 TCP는 신뢰성과 순서 보장을 제공하며, 안정적인 연결을 구축하고 종료할 수 있습니다.
