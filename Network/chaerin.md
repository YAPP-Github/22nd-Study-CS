# Data Structure 질문

<details>
<summary>Table of Contents</summary>

- [5주차 전산 기본](#5주차-전산-기본)
- [6주차 TCP/UDP](#6주차-TCP/UDP)
- [7주차 HTTP](#7주차-HTTP)
- [8주차 웹](#8주차-웹)

</details>

## 5주차 전산 기본
---
### OSI 7계층에 대해서 설명해주세요.
---
OSI 계층: 네트워크 프로토콜을 계층적으로 구성하여 컴퓨터 네트워크에서의 통신을 설명하는 데 사용되는 개념적인 프레임워크
1. 물리 계층 (Physical Layer): 리피터, 케이블, 허브 등  
네트워크의 하드웨어적인 부분  
데이터를 전기 신호로 변환하여 전송하는 역할을 수행하며, 전송 매체와 연결 방식, 전압 등의 특성을 다룹니다.  
단위:bit → 전기적 신호 의미  
2. 데이터 링크 계층 (Data Link Layer): 브릿지, 스위치 등   
물리 계층의 오류 수정과 흐름 제어를 담당  
물리 주소 할당 (ex. mac 주소)  
프레임 단위로 데이터를 관리하고, 맥 주소를 사용하여 인접한 네트워크 장치 간의 통신을 제어합니다.  
3. 네트워크 계층 (Network Layer): 라우터, IP  
데이터를 패킷으로 분할하고 경로 설정, 라우팅, 흐름 제어 등을 담당  
논리 주소 할당 (ex. IP)  
IP 주소를 사용하여 패킷의 목적지까지 최적의 경로로 전달  
4. 전송 계층 (Transport Layer): TCP, UDP  
데이터의 신뢰성과 흐름 제어   
데이터를 세그먼트로 분할하고, 오류 검출 및 복구, 재전송 등의 기능을 수행합니다.
TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)가 이 계층에서 사용  
6. 세션 계층 (Session Layer): API, Socket  
양 끝단의 애플리케이션 간의 대화 관리를 담당  
세션 설정, 유지, 종료 등의 기능을 제공하여 데이터의 흐름을 관리  
7. 표현 계층 (Presentation Layer): JPEG, MPEG 등  
데이터의 형식을 변환하고, 암호화, 압축, 인코딩 등의 데이터 포맷 관련 기능을 담당  
데이터를 애플리케이션에서 이해할 수 있는 형태로 변환합니다.  
8. 응용 계층 (Application Layer): HTTP, FTP, DNS 등  
사용자가 네트워크에 접근할 수 있도록 서비스를 제공  
이메일, 파일 전송, 웹 브라우징 등의 다양한 애플리케이션과 상호작용하여 사용자의 요구를 처리  

+ 1-4계층의 단위가 각각 다른데요. 각 계층에서 쓰이는 단위 설명 부탁드립니다.  
1계층의 단위는 bit
2계층 단위 frame
3계층 단위 packet
4계층 단위 segment(TCP), datagram(UDP)
+ OSI 7계층은 네트워크 프로토콜을 계층적으로 나눈건데요. 왜 계층으로 나눠서 구분할까요?  
통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문이다

---
### TCP/IP 4계층에 대해서 설명해주세요.
---
1. 네트워크 접근 계층 
네트워크 하드웨어와 상호작용  
데이터를 전송 매체(물리적인 네트워크 케이블 등)를 통해 전송하는 역할을 담당  
이 계층은 이더넷, Wi-Fi, PPP 등과 같은 프로토콜을 사용하여 데이터를 전송  
2. 인터넷 계층  
데이터의 전송과 경로 설정을 관리  
이 계층에서는 IP를 사용하여 패킷을 주고받으며, IP 주소를 사용하여 목적지까지의 경로를 결정  
라우팅, 패킷 분할 및 조립, 오류 검출 등의 기능을 수행합니다.  
3. 전송 계층  
데이터의 신뢰성과 흐름 제어를 담당  
이 계층에서는 TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)라는 두 가지 프로토콜이 주로 사용됩니다.  
TCP는 신뢰성 있는 연결 지향적인 통신을 제공하며, UDP는 비신뢰성이지만 실시간 통신에 유용한 통신을 제공합니다.  
4. 응용 계층  
사용자가 네트워크에 접근할 수 있도록 서비스를 제공  
이 계층에서는 다양한 응용 프로토콜 및 서비스가 동작하며, 이메일 (SMTP, POP3), 웹 (HTTP, HTTPS), 파일 전송 (FTP) 등과 같은 다양한 애플리케이션과 상호작용  
이 계층은 사용자와 상호작용하는 최상위 계층  

TCP/IP는 실제로 인터넷에서 널리 사용되는 프로토콜 스택이며, OSI 모델은 이론적인 참조 모델로 네트워크 설계와 프로토콜 개발에 사용  


---
### DNS가 무엇인가요?
---
인터넷 상에서 도메인 이름을 IP 주소로 변환하거나, IP 주소를 도메인 이름으로 변환하는 시스템  
전세계적으로 약속된 규칙을 공유  
상위 기관과 하위 기관과 같은 계층 구조를 가지는 분산 데이터베이스 구조

+도메인과 URL의 차이점?  
도메인은 인터넷에서 식별되는 이름 url의 일부이며,  
URL은 리소스에 접근하는 주소로 도메인을 포함한 경로입니다.  
URL에는 도메인 이름과 전송 프로토콜 및 경로 등의 정보가 포함되며 리소스의 위치를 나타낸다.

+DNS 서버의 종류?  
Recursive(재귀) 네임 서버 : 인터넷 사용자가 가장 먼저 접근하는 DNS 서버로 특정 도메인에 대한 IP정보를 캐시 형태로 저장해놓습니다.
대표적으로 KT/LG/SK 와 같은 ISP(통신사) DNS 서버가 있습니다  
Root 네임 서버 : DNS 레코드를 요청하는 첫 단계입니다.  
비영리 단체인 ICANN(Internet Corporation for Assigned Names and Numbers)이 관리합니다.  
TLD(최상위 도메인) 네임 서버 : TLD 네임서버는 .com, .co.kr 과 같은 점 뒤에오는 도메인 확장자를 사용하는 모든 도메인 정보를 유지합니다.  
second level 네임 서버 : 실제 도메인의 IP주소가 기록되는 서버입니다. 도메인/호스팅 업체의 '네임서버'를 말합니다.  

---
### 도메인 이름으로 실제 IP를 어떻게 찾을 수 있는지 흐름을 설명해 주세요.
---
OSI 7계층과도 연관지어 설명하라는 질문을 받은적도 있습니다.  

브라우저가 URL에 적힌 값을 파싱해서 HTTP Request Message를 만들고, OS에 전송 요청을 합니다. 
이 때, Domain으로 요청을 보낼 수 없기 때문에 DNS Lookup을 수행합니다.  
DNS 룩업 과정은 크롬의 경우 브라우저 → hosts 파일 → DNS Cache의 순서로 도메인에 매칭되는 ip를 찾습니다.  
일반적으로 설명하는 DNS Lookup은 루트 도메인서버에서부터 서브도메인 서버순으로 찾게됩니다.  
이 요청은 프로토콜 스택이라는 OS에 내장된 네트워크 제어용 소프트웨어에 의해 패킷에 담기고 패킷에 제어정보를 덧붙여 LAN 어댑터에 전송하고, LAN 어댑터는 이를 전기신호로 변환시켜 송출합니다.  
패킷은 스위칭 허브 등을 경유하여 인터넷 접속용 라우터에서 ISP로 전달되고 인터넷으로 이동합니다.  
액세스 회선에 의해 통신사용 라우터로 운반되고 인터넷의 핵심부로 전달됩니다. 고속 라우터들 사이로 목적지까지 패킷이 흘러들어가게 됩니다.  
핵심부를 통과한 패킷은 목적지의 LAN에 도착하고, 방화벽이 패킷을 검사한 후 캐시 서버로 보내어 웹 서버에 갈 필요가 있는지 검사합니다.  
웹 서버에 도착한 패킷은 프로토콜 스택이 패킷을 추출하여 메시지를 복원하고 웹 서버 애플리케이션에 넘깁니다.  
애플리케이션은 요청에 대한 응답 데이터를 작성하여 클라이언트로 회송하고, 이는 전달된 방식 그대로 전송됩니다.  

## 6주차 TCP/UDP
---
### TCP와 UDP의 차이에 대해서 설명해 주세요.
---
**TCP(Transfer Control Protocol)**

연결형 프로토콜 → 클라이언트와 서버가 연결된 상태에서 데이터를 주고 받음
3-way handshaking을 통해 연결 설정하고 4-way handshaking을 통해 연결 해제

신뢰성있는 데이터 전송 (데이터 재전송 존재O)
흐름 제어와 혼잡 제어를 지원하며 데이터의 순서를 보장
흐름 제어: 수신측과 송신측의 데이터 처리속도 차이를 조절하여 수신측 버퍼 오버플로우 방지
혼잡 제어: 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
연속성보다 신뢰성있는 전송이 중요할 때
UDP보다 전송 속도 느림
통신 방식: 1:1 통신

**UDP(User Datagram Protocol)**

비연결형 프로토콜 → 연결을 위해 할당되는 논리적인 경로 존재 x
TCP의 handshaking 같은 연결 설정 없음

비신뢰성 데이터 전송 (데이터 재전송 존재X)
데이터의 순서 보장 x
신뢰성보다 연속성이 중요할 때 사용
흐름 제어 x, 혼잡 제어 x 
→ TCP보다 전송 속도 빠름
통신 방식: 1:1,1:N. N:M 방식

---
### TCP 헤더에 대해서 설명해 주세요.
---
TCP 헤더는 TCP 프로토콜에서 데이터 전송과 관련된 제어 정보를 포함하는 부분
송수신 포트번호, 데이터의 순서를 지정하는 시퀀스 넘버,
세그먼트가 서로 다른 경로를 거치면서 순서가 바뀔 수 있는데 이때 시퀀스 넘버를 통해 수신측에서 순서에 맞게 재조립
수신자가 예상하는 다음 데이터의 아크넘버, 
flag bit, 세그먼트의 용도와 내용을 결정하기 위해 사용, 6가지 종류
ACK,SYN,FIN등을 표기

---
### MTU가 무엇인가요?
---
Maximum Transmission Unit

네트워크에서 한 번에 전송될 수 있는 최대 데이터 패킷 크기
데이터 링크 계층에서 전송되는 프레임의 최대 크기를 결정하고 이 크기에 맞춰 데이터 전송 시 데이터를 적절한 크기의 패킷으로 분할해 전송

---
### 3-way hand shake, 4-way hand shake 흐름에 대해서 설명해주세요.
---

**3-way hand shake (**TCP 연결 설정 시 사용)

**Client > Server :  SYN**

**Server > Client :  SYN, ACK**

**Client > Server :  ACK**

**[STEP 1] Client -> Server : SYN**

클라이언트→서버 접속 요청 SYN 패킷 전송
이때 클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태, 
서버는 Wait for Client 상태

**[STEP 2] Server -> Client : SYN, ACK**

서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷 발송
클라이언트가 다시 ACK으로 응답하기를 대기
이때 서버는 SYN_RECEIVED 상태가 된다.

**[STEP 3] Client -> Server :  ACK**

클라이언트는 서버에게 ACK을 보내고 이후 연결이 이루어지며 데이터 교환

이때의 서버 상태 ESTABLISHED

**4-way hand shake (TCP 연결 해제 시 사용)**
**Client > Server :  FIN
Server > Client :  ACK
Server > Client :  FIN
Client > Server :  ACK**

**[STEP 1] Client -> Server :  FIN**

클라이언트가 연결을 종료하겠다는 FIN플래그 전송
이때 클라이언트는  FIN-WAIT 상태

**[STEP 2] Server -> Client :  ACK**

서버는 FIN  플래그를 받고, 일단 클라이언트에 확인메시지 ACK 전송
자신의 통신이 끝날때까지 기다리는데 이 상태가 서버의 CLOSE_WAIT 상태

**[STEP 3] Server -> Client :  FIN**

서버에서 연결 해제할 준비가 되면, 
연결 해제를 위한 준비가 되었음을 알리기 위해 클라이언트에 FIN플래그 전송
이때 서버의 상태는 LAST-ACK

**[STEP 4] Client -> Server :  ACK**

클라이언트는 해지 준비가 되었다는 ACK를 서버에 전송
클라이언트의 상태 FIN-WAIT ->TIME-WAIT 으로 변경
일정 시간 지난 후 CLOSE 상태로 전환 → 아직 도착하지못한 잉여 패킷 유실 방지위해

## 7주차 HTTP
---
### HTTP와 HTTPS 의 차이는 무엇인가요?
---

HTTP는 클라이언트와 서버 간에 데이터를 주고 받기 위한 프로토콜
기본 포트: 80
암호화 되지않은 데이터를 주고 받아 중간에 탈취 될시 보안상 위험

이러한 보안 문제를 해결하기 위해 HTTPS 등장
SSL,TLS 프로토콜 위에서 HTTP 프로토콜이 작동하는 것
기본 포트: 443
SSL/TLS 인증을 통해 암호화를 진행하고 발신자, 수신자만 해당 암호 디코딩 가능
SSL은 과거 버전이며 TLS가 현재 버전
TLS인증서 우분투서버에서 let’s encrypt활용해 TLS 인증서 발급 받고
nginx에서 리디렉션 설정으로 80번 포트 요청 들어올 시 443 포트로 리디렉션 처리 넣었음

TLS 계층의 암호화 방식 - 공개키 활용 handshaking
+) 프로토콜: 컴퓨터 내부, 또는 컴퓨터 간에 데이터 교환 방식을 정의하는 규칙 체계
SSL/TLS 인증서는 제 3자가 서버와 클라이언트 통신을 보증해주는 문서

---
### HTTPS가 동작하는 방식에 대해서 설명해 주세요.
---

[서버] 비대칭키인 공개키와 개인키 생성
[서버] 공개키와 서버 관련 정보를 CA 기관에 전달
[CA] 전달받은 정보로 인증서 발급
[CA] CA 비밀키로 인증서 암호화하여 서버에 전달

[서버] 공개키와 개인키, 인증서 갖고 있음
[클라이언트] 서버에 접속 요청
[서버] 클라이언트에 CA 인증서, 공개키 전달
[클라이언트] 전달받은 인증서를 CA의 공개키로 복호화하여 검증
[클라이언트] 검증되면 클라이언트의 대칭키(비밀키)를 전달받은 공개키로 암호화해 서버에 전달
[서버] 전달받은 키값을 서버 개인키로 복호화 후 대칭키 획득
이후 서버, 클라이언트가 동일한 대칭키(비밀키로) 통신

+대칭키: 암호화, 복호화 둘다 비밀키
비대칭키: 암호화, 복호화 다른 키, 암호화는 공개키 복호화는 개인키

---
### HTTP 1.0과 1.1의 2.0와 그 특징에 대해서 설명해 주세요.
---

**[HTTP 1.0]**
헤더 개념 추가
응답에 상태 코드 추가
content-type 도입으로 html 이외의 문서 전송 가능해짐
한계-커넥션 하나 당 요청 하나와 응답 하나만 처리 가능

**[HTTP 1.1]**
파이프라이닝 추가해 앞의 요청을 기다리지 않고 순차적으로 여러 요청 연속 전송
한계-하나의 커넥션에 여러 요청이 들어 있을 뿐, 동시에 여러 요청 처리 불가능
앞의 요청이 오래 걸리면 기다릴 수 밖에 없음
중복된 헤더 전송으로 인한 오버헤드 큼

**[HTTP 2.0]**
binary frame으로 데이터 인코딩하여 전송
multiplexed stream을 도입하여 하나의 커넥션 안에 여러 stream 존재
동시에 여러 요청 처리 가능해짐
요청과 응답의 헤더 메타데이터를 압축해서 오버헤드 감소

**[HTTP 3.0]**
QUIC을 기반으로 나온 새로운 HTTP 메이저 버전
QUIC: Google에서 개발한 UDP 기반의 전송 프로토콜,
TCP의 3-way handshake과정을 최적화 하는 것에 초점을 두고 개발됨

---
### keep-alive 헤더에 대해서 설명해 주세요.
---

매번 똑같은 주소로 요청을 할 때마다 커넥션을 새로 연결할 수 없으니
네트워크 비용 감소를 위해 커넥션을 계속 유지해달라는 요청 의미의 헤더
유지 시간과 최대 요청 개수 정보를 포함함

---
### HTTP GET과 POST의 차이는 무엇인가요?
---

사용 목적:  
GET- 서버의 리소스에 데이터 요청, DB 문법으로 따지면 select 구문과 유사  
POST- 서버의 리소스 생성 요청, DB 문법으로 따지면 create 구문과 유사  
요청의 바디값 유무:  
GET-url 쿼리 스트링으로 데이터를 보내 바디 존재x  
POST-body에 요청 데이터를 담아 보내기위해 존재   
멱등성:  
GET-단순히 조회만 하기에 멱등  
POST-생성이 일어나기 때문에 멱등하지 않음  

+ 멱등: 연산을 여러 번 적용하더라도 데이터의 결과 값이 달라지지 않는 성질  
데이터 길이 제한:  
GET- 길이 제한 o  
POST-길이 제한 x  
성공 응답 코드:  
GET- 200  
POST-201  

---
### 쿠키와 세션에 대해서 설명해 주세요.
---

HTTP 프로토콜 환경은 기본적으로 응답을 받으면 연결을 끊고 상태를 유지하지 않는 특성   
이를 해결하기위해 쿠키와 세션 사용  
웹 통신시 필요한 정보를 유지하기 위해 데이터 저장용으로 사용  
[쿠키]  
클라이언트의 PC에 유지 필요한 정보 저장  
이름, 값, 만료일로 구성  
저장가능한 수에 제한이 있음  
사용자가 웹 사이트에 접근하면 클라이언트에서 서버로 요청을 보내고  
서버에서 쿠키를 생성해 돌려주는 응답에 같이 쿠키를 보냄  
클라이언트는 쿠키를 로컬 PC에 저장해 다음에 다시 서버에 요청을 보낼 때 쿠키를 같이 보냄  
만료시간이 되면 삭제되어 브라우저를 종료해도 남아있을 수 있음  
[세션]  
세션은 쿠키를 기반으로 하지만 클라이언트가 아닌 서버사이드에 저장  
클라이언트는 세션 ID로 구분되며 웹 브라우저가 서버에 접속해 브라우저를 종료할 때까지 세션 유지  
만료시간과 상관없이 브라우저가 종료되면 세션 삭제됨  
서버에 요청을 보내는 유저가 많아질 경우 서버 부하 커짐  
http 통신시 직접 데이터가 담겨서 이동되지 않으므로 보안상 더 우수  


## 8주차 웹
---
### 웹브라우저에서 서버로 요청했을 때, 흐름을 설명해주세요.
---

유저가 웹브라우저에 웹사이트 URI 입력하거나 웹사이트에서 링크 클릭 등의 작업 수행  
브라우저는 입력받은 주소 또는 요청을 기반으로 HTTP 요청 생성  
생성한 HTTP 요청을 서버로 전송  
이때, HTTP 요청은 크게 URI,헤더,바디로 구성  
이때 DNS를 활용해 도메인 주소가 IP 주소로 변환됨  
서버는 요청을 받아 URI를 확인하고 요청에 맞는 응답을 생성  
생성된 응답을 다시 웹브라우저에 전송  
웹 브라우저는 받은 응답을 활용해 웹페이지에 렌더링  
유저가 웹 페이지에서 정보 확인 가능  

---
### CORS란 무엇인가요?
---

CORS(Cross-Origin Resource Sharing)  
origin: 프로토콜+호스트+포트  
다른 출처의 리소스 공유에 대한 허용 정책   
같은 origin이 아니더라도 리소스 공유를 허용하는 것  
보안 상을 이유로 SOP(same origin policy)를 추구하는데 이로 인해 다른 출처간의 리소스를 가져오는게 제한적이게됨  
이를 해결해주는게 CORS  
클라이언트, 서버가 헤더에 origin 관련 정보를 담아 허용된 출처간에서만 통신 가능  

---
### 웹 서버와 웹 어플리케이션 서버(WAS)의 차이는 무엇인가요?
---

웹 서버  
:http 요청을 받아 html과 같은 정적 컨텐츠를 제공하는 서버  
WAS를 거치지 않고 바로 요청한 컨텐츠 제공 가능  
:동적인 컨텐츠 제공을 위헤 요청 WAS로 전달  
ex. apache, nginx 등  

웹 어플리케이션 서버  
:http 기반 동적 컨텐츠를 제공하는 서버  
:주로 데이터베이스 서버와 같이 수행  
:웹 서버가 하는 기능 또한 WAS가 수행 가능  
웹서버를 앞단에 두고 정적인 컨텐츠를 응답하고 동적컨텐츠는 WAS에서 처리함으로써 서버 부하 방지  

---
### REST API에 대해서 설명해 주세요.
---

REST 아키텍처 스타일의 제약 조건을 준수한 API  
REST(Representational State Transfer)  
: 자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는 것  
자원을 URI(Uniform Resource Identifier)로 표현하고, HTTP 메서드를 사용하여 해당 자원 CRUD 조작  
Create : 생성(POST)  
Read : 조회(GET)  
Update : 수정(PUT)  
Delete : 삭제(DELETE)  
REST API 설계 기본 원칙  
1. URI로 자원 표기  
2. 자원에 대한 행위, 동사는 URI에 안넣고 CRUD로 표현  
3. 슬래쉬로 계층 관계 표현  
4. URI 마지막에는 슬래쉬 포함 x  
5. 언더바 대신 하이픈  
등  

---
### API Gateway란 무엇인가요?
---

모든 서버로의 요청을 단일지점을 거쳐서 처리  
클라이언트(웹 브라우저, 모바일 앱 등)에서 오는 API 요청을 중앙 집중화된 API Gateway 서버로 라우팅하고, 해당 요청을 처리할 백엔드 서비스로 전달  
라우팅  
:요청된 API를 해당하는 백엔드 서비스로 라우팅  
로드 밸런싱  
:로드 밸런싱을 통해 요청을 분산시켜 서비스의 가용성과 성능을 향상  
인증,인가  
:클라이언트를 인증한 후 api 토큰을 주는 등 API 호출을 허가해줌  

---
### API Gateway가 다운되면 모든 API를 사용 못할지도 모르는데, 어떤 방안을 마련해야 할까요?
---

API Gateway를 여러개 운영하고 이를 로드밸런싱으로 처리  
다운됐을 시를 대비한 대기 서비스 마련, 백엔드 서비스가 직접 API 게이트웨이의 역할을 대체할 수 있거나 다른 API 게이트웨이 인스런스로 연결  

